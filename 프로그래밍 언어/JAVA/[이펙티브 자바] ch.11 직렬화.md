## Item 85. 자바 직렬화는 대안을 찾자

### 직렬화란?

인스턴스에 대한 정보를 바이트 스트림으로 변환하여 외부로 전송하는 기법

### Json, Protocol Buffer
| JSON | Protocol Buffer, gRPC |
|--|--|
| 경량 데이터 교환 방식 | 데이터를 인코딩하는 방법, 구글에서 구조화된 데이터의 직렬/역직렬화를 위해 개발 |
| 스키마 없음 | 메시지를 정의하고 교환하기 위한 규칙필요 |
| text | binary |
| 가볍고 다른 직렬화 기술보다 빠르다 | json보다 빠름 |
| 클래스, 함수 전송 불가능 | 폭넓은 데이터 유형 지원 |

현대 어플리케이션에서 자바 직렬화를 직접 사용할일은 거의 없을 것

## Item 86. Serializable을 Implements 할지 신중히 생각하자

Serializable은 Implements하기 매우 간단하며, 구현할 별도 메서드도 없기때문에 간단하게 생각하기 쉽지만 장기적인 실무 환경에서 매우 큰 비용이 든다.

1. 릴리즈한 뒤에는 어플리케이션을 수정하기 매우 어렵다.
2. 버그와 보안 구멍이 생길 위험이 높아진다.
	- 자바 직렬화 역직렬화는 바이트 스트림을 다루는 과정에서 타입안의 모든 코드들이 노출되고 보안에 취약해지는 문제점이 존재한다 
3. 테스트 범위 증가
4. Serializable을 구현한 클래스는 상속시 문제발생 위험 존재
5. 내부 클래스는 직렬화 구현하지 말것


## Item 87. 커스텀 직렬화?

- 직렬화를 직접 구현할 일이 있을때 다시 공부해보기

## Item 88. readObject 메서드는 방어적으로 작성하자

readObject 메서드는 직렬화, 역직렬화시 바이트 스트림을 다루는 과정에서 타입안의 모든 코드들이 노출되는 대표적인 메서드이다. 따라서 해당 메서드를 작성할때는

1. private 이어야하는 객체 참조 필드가 존재한다면 각 필드가 가리키는 객체를 방어적으로 복사
2. 모든 불션식을 검사하여 어긋나는게 발견되면 예외를 던지도록 하자
3. 역직렬화 후 객체 그래프 전체의 유효성 검사를 한다면 ObjectInputValidation 인터페이스를 사용할것
4. 직접적이든 간접적이든 재정의할 수 있는 메서드는 호출하지 말것

## Item 89. readResolve 보다는 열거타입 사용하기
싱글턴으로 작성된 클래스라도 Serializable을 구현하는 순간 해당 객체는 싱글턴임을 보장할 수 없게된다.

이 때 readResolve를 사용하면 싱글턴 속성을 유지할 수 있으나 readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.

차라리 직렬화 가능한 인스턴스 통제 클래스를 열거타입을 이용해 구현하면 보다 간단히 구현가능하므로 열거타입을 고려해보자
- 하지만 열거 타입을 싱글턴 구현을 위해 사용하는것도 좋은 코드 스타일은 아니라고 본다
- 보안을 공부하는게 아니라면 readResolve까지 다룰일은 거의 없을듯?

## Item 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용검토
### 프록시 패턴![enter image description here](https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/1920px-Proxy_pattern_diagram.svg.png)


프록시 패턴은 관계된 두 객체 사이에 사이에 중계객체를 두는 디자인 패턴으로 지연 로딩, 지연 초기화를 하는 목적 등으로 자주 사용된다.

### 직렬화 프록시

- 3자가 확장할 수 없는 클래스라면 직렬화 프록시 패턴을 권장
- 불변식을 안정적으로 직렬화 가능