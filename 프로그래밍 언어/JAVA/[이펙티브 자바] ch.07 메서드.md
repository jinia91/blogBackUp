## Item 49. 매개변수 유효성 검사

### 매개변수 검사를 제대로 수행하지 못할경우 문제점
1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패
2. 메서드가 잘못된 결과를 반환
3. 당장에 결과가 반영되지는 않지만 의도치 않은 객체변화로 차후 미래에 오작동

### 매개변수값이 잘못됬을때 덩지는 예외는 문서화(주석)해놓아야됨

- 추천하는 예외 던지기
	- IllegalArgumentException, IndexOutOfBoundsException, NullPointerException

- "오류는 가능한 한 빨리 잡아야한다"는 일반원칙상, 유효성검사는 메서드 도입부에 반드시 검사하는것이 바람직
	- 실무에서는 Controller 단이나 Service단에서 하는것이 바람직
	- 단순 유효성검사라면 Validate를 써서 Controller에서 수행
	- 비지니스 로직상의 유효성검사라면 Service에서 하는것이 바람직할 것
	- 변동하기 쉬운데이터일수록 가장 나중에 유효성검사를 하는것이 바람직
	- [유효성 검사 코드 예시](https://github.com/jinia91/SpringbootMvcBoard/blob/3d162ab58bda95f1f2ef87fda958a2219f16ed16/board/src/main/java/com/project/board/user/controller/UserController.java#L41)

### 어디서 호출되는지에 따라 유효성 검사의 중요성은 더해질수 있다
- 공개된 API라면 parameter 검사 기준은 매우 엄격해야함!
- test code를 통해 문서화를 보완하는것도 좋은 방편!

## Item 50. 적시에 방어적 복사본을 만들어라

### Date 클래스의 문제점(참조)
**1. 불변객체가 아니다**

- set으로 변경이 가능하다. 여러 객체에서 Calendar이나 Date 객체가 공유되면 한 곳에서 바꾼 값이 다른 곳 에서도 바뀌는 부작용이 생길 수있다.

- 멀티 쓰레드 환경에서 안전하지 못하다.

**2. 윤초와 같은 특별한 상황을 고려하지 않았다.**

**3. 상수 필드 남용**

- calendar.add( Calendar.SECOND , 2 ); Calendar.JUNE 과같이 의미없는 상수가 들어가도 컴파일 시점에서 걸러낼 수가 없다.

  

**4. 헷갈리는 월 지정**

- 월의 시작이 0이다. 그래서 6월을 쓰려면 calendar.set(1582, 5 , 4); 이렇게 써야하고

calendar.set(1582, Calendar.JUNE , 4); 같은 상수도 만들었다 (Calendar.JUNE는 5가 찍힌다.)

일부러 가독성을 높이기위해 calendar.set(1582, 6-1 , 4); 이렇게 쓰기도 한다고 한다.

**5. 일관성 없는 요일 상수**

- Calendar는 일요일부터 1~7 이고 Date는 일요일이 0으로 시작한다. 두 클래스는 빈번히 서로를 불러내는데 두 클래스 사이의 일관성이 없다.

**6. 겹치는 클래스명**

-java.util.Date java.sql.Date클래스는 전자의 상속을 받는 클래스다. 그런데 클래스명이 같다니...

이렇게  **단점**이 많았다고 한다.

그 후 jdk1.8 버전에서 드디어 개선된 **java.time패키지**가 등장했다. Joda-Time 라이브러리의 영향을 많이 받았고 기존 클래스들의 단점을 극복한 새로운 API라고 한다.


### 파라미터 원본을 훼손시키는 메소드를 작성할 위험성

- 파라미터로 들어온 객체를 조작하여 훼손되고 이 객체가 다른 메서드에서 사용되어지거나 다른 쓰레드에서 사용되어지는 문제가 생길 위험성이 존재

- 이 경우 해당 메서드 내에서 방어적 복사를 통해 해결 가능

- 즉 패러미터의 객체를 수정할 상황이 생긴다면 방어적 복사본을 사용하자!


## Item 51. 좋은 API 메서드 설계 요령

1. 메서드 이름은 신중히 짓자
	- 표준 명명 규칙을 따를것(Item 68)
	- 표준 명명 규칙보다도 더 중요한 것은 같은 패키지에(시스템) 속한 다른 이름들과 일관되게 	짓기
	- 긴이름은 피하자
	- 내부 구성원간의 합의에 따를것

2. 편의 메서드를 너무 많이 만들지 말자(ex. Utill Class 소속 메서드들같은 케이스)
	- 지나치게 많은 메서드는 유지보수하기 어렵다
3. 매개 변수 목록은 짧게 유지하자(4개 이하)
	- 지나치게 매개변수를 많이넘긴다면 메서드가 장황하게 긴것은 아닌지? 리팩토링 고려할것
	- 파라미터로 vo를 넘기는것도 고려해볼것

4. 매개변수 타입으로는 클래스보다는 인터페이스가 더 낫다
5. boolean 보다는 열거타입 Enum 사용을 고려해보자

## Item 52. Overloading은 신중히 만들자
- Overloading은 정적으로 선택(컴파일 단계)되어지므로, 직관에 어긋나는 코드가 발생할 위험성이 존재
- 
- 컴파일 시점에서 Overloading된 메서드는 패러미터의 타입에 의해 정해지게 되므로, 해당 패러미터가 공변성을 지녔더라도 다른 Overloading된 메서드로 대체되지 않음

- 오버로딩은 실무에서 가독성을 해치는 상황이 발생하기 쉬우므로 실제로 사용할때는 여러번 고민해보도록 하자

### 안전하고 보수적으로 코드를 짠다고 생각할 때, 매개변수 수가 같은 Overloading 메서드는 작성하지 않는것이 바람직
- 차라리 메소드 이름을 다르게 작성하자

## Item 53. 올바른 가변인수 작성법

1. 0개, 1개 인자를 받는 메서드를 먼저 구현하자
	- 무작정 가변인수를 받는 메서드를 만들고 해당 메서드에서 0개시 에러처리, 한개시 분기로 나누기보다는 다중정의를 사용하는것을 권장
2. 성능을 생각한다면 4개 5개까지도 다중정의를 한 뒤, 가변인수로 작성하는것을 권장
	- 가변인수는 매서드를 호출할 때 마다 매번 배열을 만드는 비용이 존재한다. 따라서 성능에 민감하다면 다중정의를 사용하는것이 낫다.

## Item 54. null 이 아닌 빈 컬렉션이나 배열을 반환하라

- 널을 반환할 경우 클라이언트측에서 매번 방어코드를 작성해야하는 문제점 발생
- 빈 컬렉션을 만드는것은 널 방어를 못해 예기치 못한 에러를 만났을때 리스크에비해 그리 크지않음
- 성능상 문제가 될 경우, 빈 컬렉션 불변객체를 만들어 반환하는것을 고려해볼것
- null반환은 api사용을 복잡하게 만들고 오류처리코드만 더 만들게된다!

## Item 55. Optional의 올바른 사용법
### Optional Api Note
- 옵셔널은 "결과 없음"을 분명하게 나타낼 필요가 있고, null이 에러를 발생시킬 확률이 높은 환경에서 **null로 인한 에러를 방지하기 위해**  사용하는 클래스. 타입이 옵셔널인 변수는 null이어서는 안되며, 항상 Optional 인스턴스를 가르켜야한다.

- 즉 옵셔널을 반환하는 객체 입장에서는 해당 값이 비어있을수 있음을 명확히 명시하는 용도이며, 사용하는 클라이언트측에서는 비어있으므로 비어있을때 처리를 해야함을 명확히 작성해야한다.

- 해당 논리로 볼 때, 
	
		// 나쁜코드
		Object object = optionalObject.orElse(null);

	- orElse 메서드는 Optional이 비어있을 경우 패러미터로 받은 값을 반환, 비어있지 않을경우 값을 반환하는 메서드
	- 위와같이 비어있을때 null을 반환하는 코드는 Api Note 상에서 null로 인해 에러를 방지하기위해 Optional을 사용했음에도 null을 반환하는 모순적인 코드이므로 좋지 못한코드다.

- [Optional이 비어있을경우 비어있는 객체를 반환하는 orElse코드 예시](https://github.com/jinia91/blog/blob/c62a003d261fe881a39397aa98f0b139d50c1168/src/main/java/myblog/blog/article/controller/TempArticleController.java#L32)
- [Optional이 비어있을경우 orElseThrow를 통해 원하는 예외를 던지기](https://github.com/jinia91/blog/blob/c62a003d261fe881a39397aa98f0b139d50c1168/src/main/java/myblog/blog/article/service/ArticleService.java#L216)

- 빈 컬렉션, 빈 배열,  옵셔널 등 컨테이너로 사용되는 타입들을 다시 옵셔널로 감싸는것은 좋지 못한 방법이므로 사용하지 말것

- 기본타입을 박싱하고 옵셔널로 감싸는것 또한 그리 좋은 코드는 아님 차라리 OptionalInt, OptionalLong, OptionalDouble 등을 사용하길 권장

## Item 56. 공개된 API 요소에는 항상 문서화 주석을 작성할것
- 되도록이면 모든 클래스, 인터페이스, 메서드, 필드선언에 문서화 주석을 달아주는것이 바람직

- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야함
	- how가 아니라 what 무엇을 하는지
	- 클라이언트가 해당 메서드를 호출하기위한 전제조건(유효성검사)
	- 메서드가 완료되었을때 사후조건
	- 부작용에대해서도
	- @param @return @throws 태그들을 적극적으로 활용하기

- 주석안에 html 태그도 사용가능하다

- 책의 내용은 라이브러리를 만드는 수준의 공개 api 주석 작성법이라서 지금당장에 숙지할필요는 없을듯 나중에 필요하면 찾아보도록 하자
