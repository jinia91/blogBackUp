## 개요

나같은 경우 깊은 복사 vs 얕은 복사 문제는 프로젝트를 진행하거나 코딩테스트 문제를 풀다 종종 만났다. 보통 깊은 복사가 되었으리라는 전제로 코드를 작성하다가 막상 코드를 구동했을때 얕은복사로 작성되어져서 예기치 못한 결과가 나오곤 했다.

물론 디버깅 자체는 크게 어렵지 않지만, 이번 기회에 제대로 정리해보자!


## 변수의 기본타입과 참조타입

얕은복사 깊은복사의 개념을 정확히 이해하기 위해서는 자바의 기본타입과 참조타입 차이에 대해 이해할 필요가 있다.

사실 얕은 복사, 깊은복사는 자바뿐 아니라 다른 프로그래밍 언어(특히 객체지향)에서도 존재하는 메타 이슈이므로 원리를 정확히 알아두면 도움이 될 것이다.

자바에서 변수를 선언할 때 변수의 타입을 선택하며 타입은 크게 **기본형**과 **참조형**으로 나뉜다.

![image](https://t1.daumcdn.net/cfile/tistory/99E8E24B5B613AB212)

기본타입과 참조타입은 여러가지 차이가 존재하지만 이 글에서 주목할 점은 타입 값들이 저장되는 **메모리의 위치**다.

**변수**는 선언 위치에 따라 JVM이 관리하는 메서드영역 혹은 스택영역에 생성되지만, **변수에 연결되는 값**(변수가 가리키는 값)은 초기화시 타입에 따라 별도의 메모리 영역에 생성될 수 있다.

![image](https://t1.daumcdn.net/cfile/tistory/99FC1A385B61558B32)

   - 변수 선언 : 선언 위치에 따라 메서드 영역 혹은 쓰레드 영역에 변수 생성
   - 변수 초기화 : 
        - 자료타입인 경우 : 선언된 **변수에** **자료타입값을 그대로 저장**
        - 참조타입인 경우 : **힙영역에** 존재하는 객체를 가리키며 이때 해당 **객체의 주소를 변수에 저장**

> 여기서 **힙영역에 존재하는 객체** 라고 표현한 것은 변수의 초기화가 객체를 생성하는 의미는 아니기 때문이다. <br>객체의 생성은 new 생성자를 통해 메서드 호출로 생성된것이고 생성된 객체의 주소값을 변수가 초기화하면서 가리키는것이다. 변수의 초기화와 객체의 생성을 분리해서 생각할 수 있어야한다.

여기서 자료타입의 경우 특별히 문제될 것이 없지만, 참조타입의 경우 인간의 일반적인 직관과 차이가 발생하며, 얕은 복사, 깊은복사 이슈가 발생하게 된다.


## Shallow Copy(얕은 복사)

프로그래밍에서 얕은 복사란 **참조주소값**을 복사하는 걸 의미한다.

        int a = 1;
        int b = a;	
	
	int[] arr1 = {1};		
	int[] arr2 = arr1;


위의 간단한 코드를 보면 

자료타입 변수 a 는 정수 1을 값으로 갖고 b도 a의 값인 1을 갖게 된다. 여기서 중요한점은 b가 a의 주소를 복사한것이 아닌, a의 값을 그대로 복사해 담았다는 것이다. 즉 a와 b 변수는 값으로 서로 다른 메모리 주소를 가리키고 있는셈이다.

반면 `arr1`은 1이라는 정수를 가진 배열 객체를 가리키는 변수이며, `arr2`는 `int[] arr2 = arr1;` 라는 초기화를 통해 `arr1`의 **참조주소값을 담았으므로** 결국 두 변수 `arr1`과 `arr2`는 하나의 메모리 주소를 가리키고 있게된다.

![첨부 이미지](https://github.com/jinia91/blogBackUp/blob/main/img/33928096-d80c-4b0f-b290-b2c07a290ec0.png?raw=true)


	b = 5;
	arr2[0] = 5;
		
	System.out.println(a);                    // 1
	System.out.println(b);                    // 5
	System.out.println(Arrays.toString(arr1));// [5]
	System.out.println(Arrays.toString(arr2));// [5]


위의 코드를 진행해보면 참조타입과 기본타입에 따른 복사 메커니즘의 차이를 명확히 확인해 볼 수 있다.

arr2는 얕은 복사를 통해 arr1의 주소값만 복사했기때문에, 힙영역의 객체를 조작하게되면 arr1과 arr2가 같은 결과를 출력하게 되는것이다.


	System.out.println(arr1.hashCode());
	System.out.println(arr2.hashCode());
	// 둘다 같은 해쉬코드가 출력됨
	// 변수이름은 다르지만 참조하는 객체는 동일!



그런데 코드를 작성하다보면 참조타입도 a,b의 결과처럼 값을 완전히 복사해 별도의 객체를 가리키길 원하는 경우가 생기게 된다. 

이럴때는 어떻게 해야할까?

## Deep Copy(깊은 복사)

가장 확실한 방법은 해당 타입의 인스턴스를 새로 만들고 복사하고자 하는 객체의 필드 값들을 인스턴스의 필드에 직접 다 집어넣는것이다.

    int[] arr1 = {1};		
	int[] arr2 = new int[1];
		
	arr2[0] = arr1[0];
	
`arr2` 변수를 초기화할때 크기가 1인 새로운 배열을 만들고 이후 `arr1[0]`의 값을 `arr2[0]`에 집어넣음으로써 두 변수는 서로 다른 객체를 가리키면서도 동등성을 가진 복사본 `arr2`가 완성된다.


### 깊은 복사의 정의

>프로그래밍에서 깊은 복사는 **객체가 가지고 있는 모든 필드의 값을 전부 복사하는 것**을 의미한다. <br>**여기서 만약 해당 필드중에 또 객체가있다면** 깊은 복사를 위해서는 그 객체도 새로운 객체를 만들어 모든 필드를 복사 해야한다.


### 깊은 복사를 구현하는 코드 패턴

깊은 복사를 하기위해 위에서처럼 모든 코드를 절차식으로 작성할 수도 있지만 보다 좋은 패턴들이 존재한다.

**1. clone() 메서드 사용**

자바의 Object 클래스는 clone() 추상 메서드를 protected 접근제한자로 제공하고 있으며,  Clonable 인터페이스를 구현하여 메서드를  오버라이딩 할 수 있다.

배열의 경우 기본적으로 clone() 메서드가 구현되어있기 때문에 별다른 걱정 없이 사용해도 무방하다.

	int[] arr1 = {1};
		
	int[] arr2 = arr1.clone();
		
	arr2[0] = 7;
	
	System.out.println(arr1[0]);
	// 콘솔에 1로 출력됨

다만 이펙티브 자바 Item 13을 보면 clone() 메서드의 재정의를 올바르게하기 위해서는 상속을 막거나 검사예외를 작성해야 하고 형변환도 해야하는 등 상당히 많은 컨벤션을 지켜야 하며

 생성자를 쓰지 않는 객체 생성 메커니즘이므로 되도록이면 사용하지 말 것을 권고하고 있다.

[이펙티브자바 Item.13 참고](https://www.jiniaslog.co.kr/article/view?articleId=102)


	int[][] arr = {{4}};
	int[][] arr2 = arr.clone();
		
	arr2[0][0] =5;
		
	System.out.println(arr[0][0]);
	// 5가 출력된다...
	
>또한 객체의 **필드에 객체가 존재**하는 구조의 경우 **clone()은 기본적으로 깊은 복사를 보장하지 않는다.** 



**2. 복사 생성자 패턴**

이펙티브 자바에서는 클래스를 작성할때 깊은 복사 로직이 필요하다면 clone() 메서드를 재정의하지말고 복사 생성자 패턴으로 구현하는것을 권장한다.

    public 임의클래스(임의클래스 original){
    this.필드 = original.get필드();
    ...
    }

자바는 상속시 생성자를 상속받지 않으므로 상속된 클래스는 다시 복사 생성자를 만들지 않는한 복사 로직을 수행할 수 없다.

따라서 유지보수 측면에서 훨씬 나은 패턴이다.

**3. 스태틱 팩토리 메서드 패턴**

     public static 임의클래스 copy(임의클래스 original) {
        임의클래스 copy = new copy();
        copy.필드 = original.get필드();
        ...
        return copy;
    }
    
또다른 방법으로는 스태틱 팩토리 메서드 패턴을 사용하는 것이다.


![첨부 이미지](https://github.com/jinia91/blogBackUp/blob/main/img/d47a1cbb-a433-45a3-b2ac-62b40e364f9f.png?raw=true)

[자바 Collections 클래스에서 스태틱팩토리메서드 패턴을 사용하여 깊은 복사를 수행하는 예시]


## References
- [조슈아 블로크, 이펙티브 자바, 인사이트](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966262281&orderClick=LEa&Kc=)
- [https://hbase.tistory.com/91](https://hbase.tistory.com/91)
- [https://zzang9ha.tistory.com/372](https://zzang9ha.tistory.com/372)