# JAVA LTS 버전
## Oracle Java Support RoadMap
| | 출시 |공식 업데이트 종료|premire Support|extended Support|Lts?|
|--|--|--|--|--|--|
| JDK8 | 2014.03 |2019.01|2022.03|2030.12|LTS|
| JDK9 | 2017.09 |2018.03|2018.03|-|-|
| JDK10 | 2018.03 |2018.09|2018.09|-|-|
| JDK11 | 2018.09 |2019.03|2023.09|2026.09|LTS|

...
현재 JDK17(LTS)까지 출시

- Premire Support : 제품 출시후 6년간의 유상 지원 서비스
- Extended Support : Premire 종료후 3년간 추가 기술지원 서비스

>LTS 버전이란 일반적인 경우보다 장기간에 걸쳐 지원하도록 고안된 에디션을 의미하며 현재 Oracle JDK는 8, 11, 17 이 LTS 버전


- 실제 프로덕트 레벨에선 JAVA 8이 가장 많이쓰이며 점차 11로 넘어가는 추세
- 17은 21.09 에 출시한 가장 최신 LTS버전으로 아직 상용단계에서 적용하기엔 라이브러리들의 호환성이나 안전성에서 확실치 않음

 **하지만 새로운 버전에 대한 꾸준한 학습은 중요하므로 11까지의 주요 변화를 알아보자**

# JAVA 8의 변화
## 함수형 인터페이스와 람다 표현식 추가

### 함수형? 객체지향?

- 명령형 프로그래밍 : 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 프로그램을 바라보는 방식
	1. 절차지향 프로그래밍 : 수행되어야 할 연속적인 계산과정을 수직으로 나열하는 방식(C, C++)
	2. 객체지향 프로그래밍 : 프로그램을 객체들 집합의 상호작용으로 표현하는 방식(java, C#, C++)
 <br/>
- 선언형 프로그래밍 : 어떻게(how)하는지를 언어로 서술하기보다, 무엇(what)을 하는지를 중점으로 작성하는 프로그래밍 방식로 특수 분야(도메인)에 특화된 추상화된 문법, 언어가 존재하여 알고리즘을 명시하지 않고도, 이를 선언해 코드를 작성하는 경우가 많다.
	1. 함수형 프로그래밍 : 순수함수를 조합하여 소프트웨어를 만드는 방식(클로저, 하스켈)
	
### 자바에서 함수형 프로그래밍의 특징
1. 함수를 1급 객체로 사용가능
2. 순수함수
	- 사이드 이펙트가 없음(함수 외부의 값을 변화 x)
	- 상태가 없다( 함수 외부의 값을 사용 x)
3. 고차함수 
	- 함수가 함수를 매개변수로 받을수 있고 리턴할 수도 있다.
	
### 함수형 인터페이스
> 추상메서드 하나만 갖고 있는 인터페이스로, 여러개의 default, static 메서드는 허용

- 익명 클래스로 구현 가능
- 람다 표현식으로 구현 가능

### 람다 표현식

- 익명 함수를 지칭하는 용어
- 자바에서는 익명 클래스, 익명 객체를 의미([엄밀히는 스코프 개념에서 차이가 존재](https://chalchichi.tistory.com/26))

### 메서드 참조
- 함수형 인터페이스의 구현이 만약 특정 클래스의 메서드와 동일하게 동작할시 이를 메서드 참조로 처리 가능
- 인텔리제이가 람다를 알아서 바꿔주기 때문에 IDE를 적극적으로 활용하자

### 더 알아보기

- [ [이펙티브 자바] ch.06 람다와 스트림](https://www.jiniaslog.co.kr/article/view?articleId=106)

## 인터페이스의 변화

### default 메서드

- 인터페이스에 메서드 선언이 아니라 구현체까지 제공하는 방법
- 해당 인터페이스를 구현한 클래스를 깨뜨리지 않으면서, 새로운 메서드 추가 가능
- 하지만 default메서드는 구현체가 모르게 기능기 추가되는것이기 때문에 그만큼 리스크가 존재한다.
	- 구현체에 따라 런타임 에러 발생 위험
	- 반드시 문서화할것!(@implSpec)
- object가 제공하는 기능은 default 메서드로 재정의 불가능
- 인터페이스를 상속받는 인터페이스에서 다시 추상 메서드로 재정의 가능
- 인터페이스 구현체가 재정의도 가능

### 다중상속시(구현시) 동일 메서드의 구현 충돌에 대해서는?

- 구현체에서 재정의를 통해 해결

### Collection 프레임워크에서의 default 메서드 추가

1. forEach() : 람다식을 사용하는 순회용
2. spliterator() : 병렬 이터레이터로 요소의 spliterator의 개수만큼 요소를 n등분해서 처리, 순서는 보장 x
3. stream() : 스트림화
4. removeIf() : 조건에 해당하는 요소 삭제
5. Comparator 관련 : 정렬시 사용하며 reverseOrder, nullFirst등 여러 메서드 추가

### default 메서드의 기능 추가로 인해 설계에서의 변화

- 기존 프레임웍, 라이브러리들이나 구조화된 아키텍쳐 애플리케이션을 만들때 많은 사람들은 인터페이스 - 빈 메서드 클래스 - 구현체 순으로 설계를 했다
- 이유는 인터페이스는 추상메서드로 구현을 강제하므로, 모든 구현체마다 메서드를 전부 구현하기엔 비효율적이기 때문
- 반면 골격 추상클래스에서 빈 메서드로 만들면 이를 다시 상속받는 구현체는 필요한 메서드만 재정의하여 사용하면 되므로 보다 유연한 구조로 구현이 가능
- 하지만 이는 고계층구조가 강제되므로 복잡도가 증가하고, 상속을 강제하는 침투적 프레임워크가 되어 구현에 제한을 가져오는 문제가 존재
- java8부터는 default메서드를 사용하면 인터페이스 - 구현체로 바로 연결시켜도 문제가 안된다!  

> springMvc의 WebMvcConfigurer 인터페이스와 WebMvcConfigurerAdapter 골격 클래스 코드를 까보면 더 이해가 잘된다. 확인해보자<br>
> 자바8, 스프링5가 되면서 WebMvcConfigurerAdapter는 위의 default 메서드 추가때문에 deprecated 되었다.

### static 메서드
- 해당 타입 관련 헬터, 유틸리티 메서드 제공시 사용가능

## Stream API 추가

### Stream의 정의와 특징

>**컬렉션, 배열등의 저장 요소를 하나씩 참조하며 함수형 인터페이스(람다식)를 적용하며 반복적으로 처리할 수 있도록 해주는 기능**"  
 
- 데이터를 담고있는 저장소가 아님
- 처리하는 데이터 소스를 변경하지 않는다.
- 중개 오퍼레이션들은 기본적으로 lazy로 작동 
- 손쉽게 병렬 처리 가능

## Optional API 추가	

### Optional 이란

>-   옵셔널은 "결과 없음"을 분명하게 나타낼 필요가 있고, null이 에러를 발생시킬 확률이 높은 환경에서  **null로 인한 에러를 방지하기 위해**  사용하는 클래스. <br> 
>\- Optional API Note

- 오직 한개의 값이 들어있을수도, 없을수도 있는 컨테이너

### Optional 특징, 주의점

- 타입이 옵셔널인 변수는 null이어서는 안되며, 항상 Optional 인스턴스를 가르켜야한다.(Optinal<String> o == null(x))
- 리턴 값으로만 쓰기를 권장(패러미터로 받는건 좋지 못함, 맵의 키타입으로도 x, 인스턴스 필드로도 x)
- Optional을 리턴하는 메서드는 null을 리턴해서는 안된다.
- 자료타입용 Optional은 따로 존재하므로 래퍼클래스를 Optional로 감싸지말자 비용낭비
- Collection은 자체로 null을 가질수 있는 컨테이너이므로 Optional로 다시 감쌀필요 없음


### 더 알아보기

- [이펙티브 자바 Item.55](https://www.jiniaslog.co.kr/article/view?articleId=107)

## Date는 그만, Time API 추가
### Date, Calender의 문제점

- mutable하기 때문에 쓰레드 세이프하지 않음
- EPOCK time을 리턴하는 방식이 혼재되어 사용시 헤깔림
- 변수명이 직관적이지 못함
- 타입 안전성이 없어 버그위험이 높음(월을 0부터 시작한다던가,,, 차라리 enum으로 받았어야) 

### Date를 대체할 Time Pakage 추가
- CLEAR
	변수명, 사용법등이 보다 명확함
- FLUENT
	가독성이 더 높아짐
- IMMUTABLE
	쓰레드 세이프한 Immutable 객체반환
- EXTENSIBLE
	확장성이 높음

## CompletableFuture

### Concurrent SW?
- 병렬 작업이 가능한 소프트웨어
- 멀티 쓰레드 환경, 혹은 멀티 프로세싱

### 과거 Java 병렬 프로그래밍
- Thread 상속으로 구현
- Runnable 구현
- sleep(), interupt(), join() 등의 메서드사용

### Java 1.5에서 추가된 병렬 프로그래밍 프레임웍 : Excutors 추가

1. 고수준 병렬 프로그래밍 프레임웍
	- 쓰레드를 만들고 관리하는 작업을 애플리케이션에서 분리
	- 그런 기능을 Excutors에 위임

2. Excutors가 하는 일
	- 쓰레드 만들기 : 애플리케이션이 사용할 쓰레드 풀을 만들어 관리
	- 쓰레드 관리 : 쓰레드 생명주기 관리
	- 작업 처리 및 실행 : 쓰레드로 실행할 작업을 조작할 API 제공
	
3. 주요 인터페이스
	- Excutors 최상위 인터페이스, 하위 구현체를 사용하는게 남
	- ExcutorService: Excutors를 상속받은 인터페이스로 보편적으로 사용할만한 메서드들 제공
	- ScheduledExecutorService: ExecutorService를 상속 받은 인터페이스로 특정 시간 이후에 또는 주기적으로 작업을 실행할 수 있다.

### Future 기능의 한계


- Future를 외부에서 완료 불가능, 취소나 타임아웃정도만 가능
- 예외처리용 api 제공
- 여러 Future 조합 불가
- 블로킹 코드를 사용하지 않고는 작업이 끝났을 때 콜	백을 할 수 없다.

	
### JAVA 8의 CompletableFuture

> 자바에서 비동기 프로그래밍을 가능케하는 인터페이스

- 비동기로 작업 가능
- 콜백 제공
- 조합하기 가능
- 예외처리 가능


## 그밖에

### 애너테이션의 변화
- 애너테이션을 타입 선언부에 사용가능(타입 패러미터, 타입 제네릭 선언부 등)
- 애너테이션을 중복해서 사용할 수 있게됨

### 배열 병렬 정렬
- parallelSort() : Fork/Join 프레임워크를 사용해서 배열을 병렬로 정렬
- 병합정렬 알고리즘
- 속도는 배열크기 초기 정렬상태등에따라 달라질수 있으므로 반드시 성능체크해볼것
### MetaSpace
JVM 영역중 PermGen 영역이 사라지고 MetaSpace 영역이 생김

**PermGen?**
- 클래스 메타데이터를 담아놓는곳
- heap 영역(eden, young, old, permGen)
- 기본값 제한 크기가 존재
- 클래스 로딩을 많이하는경우 PermGen이 가득 차는 경우가 생기고 이때 에러가터짐

**MetaSpace?**
- 클래스 메타데이터를 담아놓는곳
- 고정된 기본값 제한 크기가 존재 X
- HEAP 영역이 아니라 NATIVE 메모리 영역


# References
- [백기선, 더 자바, JAVA 8, 인프런](https://www.inflearn.com/course/the-java-java8/dashboard)
- [남궁성, JAVA의 정석 [3판], 도우출판](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994492032)
