## Item 57. 지역변수의 범위를 최소화하라

### 지역변수 사용 컨벤션

- 지역변수는 가장 처음 쓰일 때 선언하는것이 바람직

- 지역변수는 선언과 동시에 초기화함이 바람직
	- try-catch 구문같은경우 블록밖에 선언 , 내에 초기화로 분리하기도 

- 지역변수가 너무 많이 선언되는 상황이라면 메서드를 쪼개야 하는건 아닌지 확인해보자


## Item 58. 전통적인 for문 보다는 for-each문(향상된 for문)을 사용

### 향상된 for 문

- 전통적인 for문 예시

      List<String> stringList = new ArrayList<>();
      
      // 기본형
      for(int i=0; stringList.size(); i++ ){
        stringList.get(i);
      }
	  
	  // iterator 사용
	  for(Iterator<String> i = stringList.iterater(); i.hasNext(); ;){
	    String s = i.next();
	  }

- 향상된 for 문
		   
	  for(String s : stringList){
	    s;
	  }


- 향상된 for문은 코드를 간결하게 만들고 간결한 코드는 버그를 줄일수 있다!

### 향상된 for문의 단점
- 파괴적 필터링
	- remove와 같이 컬렉션의 요소 일부를 변형시키는 반복구문에서 사용이 불가능
- 다중 for문에서 명시적 인덱스의 필요성
	- 병렬반복, 다중 for문 구문에서는 엄격한 제어를 위해 인덱스를 명시하는 기존 for문을 사용하는것이 바람직하다.


## Item 59. 바퀴의 재발명을 하지말자

## Item 60. 정확한 답이 필요하다면 float, double 은 피하자

- 부동소숫점 연산은 정확하지 않음

- 돈과 관련된 비지니스 로직이라면 부동소숫점 연산은 사용하지 않는것이 바람직

## Item 61. 박싱타입대신 기본타입을 사용하기
- 박싱타입과 기본타입 혼용시 문제점
	
		Integer a = 55555; 			  // 박싱 타입 리터럴 초기화
		Integer b = new Integer(55555); // 박싱타입 객체 생성 초기화
		Integer c = 55554; c = c+1; 	  // 박싱타입 리터럴 초기화 후 오토박싱 연산
		int d = 55555; 			      // 기본타입 초기화
			
		System.out.println(a == b);	//f
		System.out.println(a == c);	//f  	
		System.out.println(a == d);	//t
		System.out.println(b == c);	//f
		System.out.println(b == d);	//t
		System.out.println(c == d);	//t
			
		System.out.println(a.equals(b));	//t
		System.out.println(a.equals(c));	//t
		System.out.println(a.equals(d));	//t
		System.out.println(b.equals(c));	//t
		System.out.println(b.equals(d));	//t
		System.out.println(c.equals(d));	//t

- 박싱타입은 기본적으로 객체 생성이므로 '==' 연산시 동등성이 아닌 동일성 판단을 내려 기대하는 결과와 다른 결과가 나올 위험성이 존재
- 따라서 위의 예제처럼 리터럴 초기화한 a, 객체생성초기화한 b, 오토박싱된 c 셋 모두 서로가 다르다는 연산결과가 나옴
	- 오토박싱 연산은 기본적으로 기본타입으로 언박싱되어 연산하고 기본타입으로 반환하지만 변수선언을 박싱타입인 Integer c로 했기때문에 다시 박싱되었음


## Item 62. 다른 타입이 적절하다면 문자열 사용은 피하라
- String을 타입처럼 사용하는 방식은 자바에서 나쁜 코드 스타일이다.

- 차라리 열거형을 사용할것(Item 34)
## Item 63. 문자열 연결은 느리니 사용을 자제하자

### 문자열연산 ( + ) 의 비효율성
실제 + 연산시 일어나는 일

> String s1 = "안녕하세요오오오오오오";
		String s2 = "방가방가";
		String s3 = s1+s2;

1. String 클래스의 valueOf호출하여 s1을 toString
2. s1을 패러미터로 StringBuilder sb 객체 생성
3. s2를 sb에 넘겨 append 시킴
4. append 시킨 최종 sb를 toString 시킴

-  문자열연산(+)이 일어날 때마다 매번 StringBuilder가 생성되고 toString으로 결과값이 반환되고 다시 StringBuilder가 생성되는 비효율적인 연산이 반복된다.

- 만약 N개의 문자열을 + 연산할 경우 N-1개의 StringBuilder 객체와 N-1개의 중간 String 객체가 생성하므로 O(N<sup>2</sup>) 의 복잡도를 갖게됨
- StringBuilder로 N개의 String을 append시켜 만들경우 StirngBuilder 객체 1개와 String객체 1개만 생성하므로  O(1) 복잡도만 갖음

## Itme 64. 객체는 인터페이스를 사용해서 참조할것

| 인터페이스 | 클래스 |
|--|--|
|유연  | 형태가 고정적 |
| 어떤구현체인지 알 수 없음 | 클래스가 명확하므로 내부가 어떤지 확인 가능|


- 객체를 참조할때 **참조객체에서 사용할 주요 메서드**를 기준으로 최대한 상위 인터페이스(클래스)를 바라보는것이 프로그램의 유연성 측면에서 바람직

## Item 65. Reflection 보다는 인터페이스를 사용하라
### 리플렉션이란?
- 프로그램에서 객체를 통해 임의의 클래스의 정보를 분석해내는 기법

-  리플렉션을 사용하면 Class 객체가 주어질 때, 그 클래스의 생성자, 메서드 , 필드의 인스턴스등을 가져올 수 있다.

> 쉽게말해 private이여도 접근 가능해짐

[리플렉션을 사용하는 모델매퍼의 예시](https://github.com/jinia91/blog/blob/c0ab4a020d8ced2e65e237fa7fc39617dcec1ef5/src/main/java/myblog/blog/base/config/AppConfig.java#L25)


### 리플렉션의 문제점

- **컴파일타임 타입 검사가 주는 이점을 누릴 수 없다.**
	- 런타임시점에 강제적으로 접근하는 방식이므로 컴파일시점에서 해당코드 체킹이 안됨
	- 반드시 실행을 해봐야만 에러가 날지 안날지 알 수 있음
- 코드가 지저분해지고 장황해진다.
- 성능이 떨어진다.

리플렉션은 컴파일 검사가 불가능한 불안정한 기능이다. 따라서 객체 생성시에만 제한적으로 사용하는것이 바람직하다.

## Item 66. 네이티브 메서드는 신중히 사용하라

### 네이티브 메서드란
- 운영체제의 시스템콜을 조작할 수 있는 메서드
- 운영체제의 시스템콜을 래핑한 특정 언어(일반적으로 C, C++)을 네이티브 랭귀지, 그리고 해당 API나 라이브러리를 네이티브 메서드라 부른다.

### JNI란
- 자바 프로그램이 네이티브 메서드를 호출하는 기술

### 네이티브 메서드를 사용하는 이유
1. 레지스트리같은 특정 플랫폼 특화 기능을 직접 건드리는 경우
2. 네이티브 코드로 작성된 기존 라이브러리를 사용하는 경우
3. ~~성능목적으로 사용~~
	- 현재는 바람직한 방법이 아님

## Item 67. 최적화는 신중히 하라

- **빠른 프로그램보다는 좋은 프로그램을 작성하라**

- 성능보다 아키텍처가 우선이다
- 성능을 제한하는 설계는 피해라
	- 컴포넌트간 / 외부 시스템과 통신하는 아키텍처

> - 빠른 프로그램을 작성하려고 안달하지 말것
> - 좋은 프로그램을 작성하다 보면 성능은 따라오기 마련
> - 시스템이 충분히 빠르다면 그걸로 괜찮다
> - 빠르지않다면 알고리즘을 우선적으로 확인하고 이후 다른 저수준 최적화를 수행하여 성능개선하기

## Item 68. 명명 규칙 컨벤션

### 패키지 명명 규칙

- 외부에 사용된다면 조직의 인터넷 도메인 역순
	- ex) com.google

- 각 요소는 8글자 이하의 짧은 단어 사용

- 필요할경우 계층을 나눠서 사용

- 패키지명은 소문자로


### 클래스 & 인터페이스 명명 규칙

- 왠만하면 줄임말 사용 금지

- 파스칼 케이스

- 약자의 경우 첫글자만 대문자로

### 메소드 & 필드 명명 규칙

- 카멀케이스

- 메서드는 동사나 목적어를 포함한 동사구
 
- 상수필드는 전체 대문자로

- 지역변수는 약어 사용해도 무방

### 문법 규칙
 
- 객체를 생성할 수 없는 클래스의 이름은 복수로(PatternsUtils)

- interface는 able or ible로 끝나는 형용사	

- 객체 타입을 바꾸는 메서드는 to~(toArrays, toString)
