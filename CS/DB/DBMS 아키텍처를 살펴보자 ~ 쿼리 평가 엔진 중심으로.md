# DBMS 란 무엇일까(개요)
DBMS 아키텍처를 자세히 살펴보기 전에 DB와 DBMS, RDB에 대해 기본적인 개념을 이해해야 한다.

전에 포스팅한 [SQL vs NoSQL](https://www.jiniaslog.co.kr/article/edit?articleId=460) 에서 간략하게 정리한바 있으므로 해당 링크를  참조하길 바란다.

# R-DBMS 아키텍처 구성요소

## R-DMBS 아키텍처 개요

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/27017b30-c9e4-4b67-a5f7-4df2e455c35c.png)

우리가 DB를 사용하기위해 DBMS에 질의(`SQL`)를 내리면, 질의는 

(1)쿼리 평가 엔진을 거쳐 실행계획이 생성되고 
(2)접근메서드가 생성된후 
(3) 버퍼 매니저 / 디스크 용량 매니저 / 트랜잭션 매니저 / 리커버리 매니저 등에 의해 관리되며 실제 실행되고 
(4) 질의한 데이터를 반환받게 된다.


## 쿼리 평가 엔진
>사용자로부터 입력받은 SQL문을 분석하고 어떤 순서로 기억장치의 데이터에 접근할지를 결정하는 역할

이때 결정되는 계획을 MySQL에서는 `Execution Plan(실행 계획)`이라고 부른다.

이러한 실행계획에 기반을 두어 데이터에 접근하는 방법을 `접근 메서드`라고 부른다.

### 쿼리 평가 엔진이 데이터에 접근하는 과정
![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/faee5fd7-f292-49f8-9a72-d33cd16bdd61.png)
### 파서(parser)
사용자로부터 입력받은 SQL이 항상 옳다는 보증이 없으므로 유효성검사와 DBMS에 효율적인 정형적 형식으로 번역해주는 역할(SQL엔진이 실제실행할수 있는 low Level은 아님)

이때 파싱된 쿼리가 캐시에 존재하는지 유무에 따라 옵티마이저 실행 여부가 갈리며, 이 과정을 Soft Parsing / Hard Parsing 으로 구분하기도 한다.

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/4324b662-dca7-4323-9f84-4b0165edee77.png)


|  | 주요 내용 | 비고 |
| --- | --- | --- |
| 공통 과정 | - 문법 체크 <br> - 오브젝트(테이블, 컬림) 및 권한유무 체크 <br> - 쿼리가 캐시에 저장되어 있는 검사 | 캐시에 쿼리가 있는경우 -> soft parsing<br> 없는경우 -> 실행계획을 만들기 위해 옵티마이저 실행(hard parsing) |

### 옵티마이저(optimizer)

옵티마이저는 DBMS의 두뇌로 옵티마이저의 알고리즘은 DBMS의 성능과 직결된다.

옵티마이저는 데이터의 인덱스 유무, 데이터 분산 또는 편향정도, DBMS 내부 매개변수 등의 조건을 고유 알고리즘을 통해 고려해 선택 가능한 많은 실행계획을 작성하고, 

이들의 비용을 연산한 뒤, 이중 가장 비용이 낮은 실행계획을 선택한다.

**옵티마이저의 종류**

1) 규칙기반 옵티마이저
    - Rule-Based Optimizer (RBO). 다른 말로 ‘휴리스틱 옵티마이저’
    - 경로별 우선순위로 규칙산정
    - 인덱스 구조, 연산자, 조건절 형태가 순위를 결정짓는 주요인

2) 비용기반 옵티마이저
    - Cost-Based Optimizer (CBO)
    - 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간
    - 레코드 개수, 블록 개수, 평균 행 길이, 칼럼 값의 수, 칼럼 값 분포, 인덱스 높이 등으로 비용 산정

3) 스스로 학습하는 옵티마이저 
    - 예상한 값과 실제 런타임 수행 결과를 비교하고, 예상치가 빗나갔을 때 실행계획을 조정하는 옵티마이저로 발전 중

우리가 사용하는 현대 DBMS의 대부분은 2번 비용기반 옵티마이저다.


### 카탈로그 매니저
옵티마이저가 실행계획을 세울때, 옵티마이저에게 중요한 정보를 제공하는 역할이자 DMBS의 내부 메타정보 통계를 모아놓은 테이블(`카탈로그`) 관리자

카탈로그(`통계정보`)는 옵티마이저가 실행계획을 작성할때 참조하는 메타정보인 만큼 성능에 가장 큰 영향을 끼치는 데이터이므로 해당 정보를 관리하고 튜닝하는 일도 중요하다.

**카탈로그에 포함된 정보**

- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 필드 크기
- 필드의 카디널리티
- 필드값의 히스토그램(분포도)
- 필드 내부 null 수
- 인덱스 정보

## 최적의 실행조건 작성을 위해 고려할 요소들

### 옵티마이저에 영향을 미치는 요소

- SQL과 연산자 형태 : 어떤 연산자를 사용했는지에 따라서 쿼리 성능에 영향을 미침 
- 옵티마이징 팩터 : 쿼리를 똑같이 작성해도 인덱스, 클러스터링, 파티셔닝 에 따라 실행계획 달라짐 
- DBMS 제약 설정 : 참조 무결성, PK, FK 등의 제약 설정은 쿼리 성능 최적화 하는데 중요한 정보 제공 
- 옵티마이저 힌트 : 옵티마이저 판단보다 사용자 지정 힌트가 우선적임 
- 통계정보 : CBO의 모든 판단 기준은 통계정보에서 나옴 
- 옵티마이저 관련 파라미터 : DBMS 버전을 업그레이드 하면 파라미터 추가 또는 변경 
- DBMS 버전과 종류

### 옵티마이저의 한계점 파악
-  옵티마이징 팩터의 부족
    사용자가 지정한 인덱스, 클러스터링 등의 옵티마이징 팩터를 제공하지 않는다면 좋은 실행계획이 되지 못한다.

- 통계정보의 부정확성
    100% 정확한 통계정보를 유지하기는 현실적으로 불가능 함. 
예를 들어 컬럼 값의 분포가 일정하다는 보장이 없음.

- 바인드 변수 사용 시 균등분포 가정
    정확한 컬럼 히스토그램을 보유하더라도 바인드 변수를 사용한 SQL에는 무용지물임. 
조건절에 바인드 변수를 사용하면 옵티마이저가 균등분포를 가정하고 비용을 계산.

- 비현실적인 가정
    예를 들어, 예전 DBMS에서는 Single Block I/O와 Multi Block I/O의 비용을 같게 평가함.

- 규칙에 의존하는 CBO
    비용기반 옵티마이저라도 부분적으로는 규칙에 의존.

- 하드웨어 성능
    옵티마이저 개발팀이 사용한 하드웨어 성능에 맞춰져 있음. 실제 운영 하드웨어와 사양이 다를 때 잘못된 실행 계획을 세울 수 있음.


## 실행계획 Details With MySQL

MySQL의 쿼리 평가 엔진을 통해 만들어진 실제 실행계획을  보는법을 간략하게 살펴 보겠다.

### 실행계획 보기

>EXPLAIN [EXTENDED] SELECT ... FROM ... WHERE ...

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/684dfe40-b25b-4f42-8f65-59f2cd9f05a4.png)


|  |  |
| --- | --- |
| id | select 아이디로 select을 구분하는 번호 |
|  select type| select에 대한 타입 |
| table | 참조하는 테이블 |
| partitions type | 테이블의 파티션중 어떤 파티션을 사용했는지 등의 정보를 조회 |
| possible keys key | 데이터를 조회할 때, DB에서 사용할수 있는 인덱스 리스트 |
| key | 실제로 사용할 인덱스 |
| key len | 실제로 사용할 인덱스의 길이 |
| ref | Key안의 인덱스와 비교하는 컬럼(상수) |
| rows | 원하는 행을 찾기 위해 얼마나 많은 행을 읽어야 할 지에 대한 예측값을 의미 |
| filtered | Filtered 칼럼에는 MySQL 엔진에 의해 필터링되어 제거된 레코드를 제외하고 최종적으로 남은 레코드의 비율(%) |
| extra | 추가 정보 |
### id
행이 어떤 select 구문을 나타내는지 알려주는 값으로 원 구문에서의 순서에 따라 각 select 구문들에 순차적으로 번호가 부여된다.
### table
행이 어떤 테이블에 접근하는지를 보여주는 것으로 대부분의 경우 테이블의 이름이나 앨리어스로 나타난다.

### select type(details)


|  |  |
| --- | --- |
| Simple | 단순 select |
| Primary | 서브 쿼리(from) 사용시, 혹은 Union 사용시 가장 외부에 있는 쿼리 |
| Union | Union쿼리에서 Primary를 제외한 나머지 |
| Dependent_union | union과 동일하나, 외곽 쿼리에 의존적 |
| Union_result | union의 결과물 |
| subquery | 서브 쿼리, 또는 서브 쿼리를 구성하는 여러 쿼리중 첫번째 |
| dependent_subquery | 서브쿼리와 동일하나 외곽쿼리에 의존적 |
| derived | select로 추출된 테이블 |
| uncacheable_subquery | 서브쿼리와 동일하지만 공급되는 모든 값에 대해 서브쿼리를 재처리. 외부 쿼리에서 공급되는 값이 동일하더라도 캐시된 결과를 사용 불가능 |
| uncacheable_union | 유니온과 동일하지만 공급되는 모든 값에 대해 union쿼리를 재처리 |

### type(details)


|  |  |
| --- | --- |
| system | 테이블에 데이터가 단 하나인 경우 |
| const | PK,UK 조회시 단한건 |
| eq_ref |조인을 할 때 PK  |
| ref | 조인을 할 때 PK,UK가 아닌 키로 매칭되는 경우 |
| ref_or_null | ref + null 포함 |
| index_merge | 두개의 인덱스가 병합되어 검색이 이루어지는 경우 |
| unique_subquery | 서브쿼리에서 pk가 오는 특수한 경우 |
| index_subquery | 서브쿼리에서 인덱스가 오는 특수한 경우 |
| range | 특정 범위 내에서 인덱스를 사용해 원하는 데이터를 추출 |
| index |  인덱스 풀 스캔|
| all | 테이블 풀 스캔 |


### key_len
MySQL이 인덱스에 얼마나 많은 바이트를 사용하고 있는 지를 보여준다. MySQL에서 인덱스에 있는 컬럼들 중 일부만 사용한다면 이 값을 통해 어떤 컬럼들이 사용되는 지를 계산할 수 있다.

### extra(details)

|  |  |
| --- | --- |
| using index |커버링 인덱스, 인덱스 사용 |
| using where | where조건으로 데이터 추출, 만약 type all, 또는 index타입과 함께 표현되면 성능이 좋지 않다는 의미 |
| usuing filesort | 데이터 정렬이 필요한 경우로 메모리 혹은 디스크상에서 정령을 모두 포함, 결과 데이터가 많은 경우 성능에 많은 영향을 주므로 주의 |
| using temporary | 쿼리 처리시 내부적으로 임시 테이블 사용 유무 |

- using filesort와 using temporarty는 일반적으로 좋지 않은 쿼리를 의미하므로, 쿼리튜닝 혹은 슬로우쿼리 모니터링이 필요

## 버퍼 매니저

>DBMS의 데이터는 기본적으로 영속화를 위해 디스크에 저장이 된다. 하지만 성능을 위해 메모리도 적극적으로 사용하는데, 버퍼 매니저는 그 캐싱을 담당하는 역할을 한다.


### 데이터 캐시
> 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역, 일반적으로 조회속도 향상을 위해 사용하며, SELECT을 통해 찾는 데이터가 데이터 캐시에 존재할 경우, 디스크까지 접근하지 않아도 되므로 빠른 응답속도를 기대할 수 있다.

`디스크를 건드리는 자는 불행해진다` 라는 관용구도 존재할만큼, 잦은 디스크 조회는 퍼포먼스에 악영향을 준다.


### 로그 버퍼

>갱신처리와 관련된(`update delete merge insert등`) 영역.

- DBMS는 갱신과 관련된 SQL을 받으면 곧바로 저장소에 있는 데이터를 변경하지 않고 일단 로그버퍼위에 변경정보를 보낸뒤, 이후 디스크에 변경(`로그 파일추가`)를 수행한다.(`COMMIT, FLUSH`)

- 즉 갱신처리시 로그 버퍼에 미리 기록하고 사용자에게 보여준 뒤, 커밋을 통해 후처리를하는 비동기적 처리가 일어난다. 이는 디스크 접근시 일어날 레이턴시를 분리하기 위함이다.
- 잦은 커밋은 잦은 동기적 처리를 의미하며, 데이터 정합성은 높아지지만 성능상으론 악영향을 줄 수 있다.

### 워킹 메모리
>DBMS가 정렬 또는 해시 처리에 사용하는 메모리상 작업용 영역

- MYSQL은 정렬버퍼라는 명칭으로 부름

해당 영역이 작아 SQL시행시 메모리 초과가 일어나면, 디스크에 접근하여 SWAP(Paging)이 일어나므로 성능상 큰 저하가 발생할 수 있다.
## 그외

아래 부분들 역시 DBMS를 구성하는 매우 중요한 요소이며, 대규모 시스템에서 트랜잭션 매니저나 락 매니저는 성능을 크게 좌우하는 부분이지만, 

이를 자세히 다루기에는 너무 본격적인 내용이므로 본 포스팅에서는 간략하게만 정리하겠다.

### 디스크 용량 매니저
>DBMS가 데이터를 영구적으로 저장하고 읽고 쓰기를 제어할지 관리하는 역할

### 트랜잭션 매니저와 락 매니저
> 트랜잭션의 정합성을 유지, 실행시키고 필요한 경우 데이터에 락을 걸어 다른사람의 요청을 대기시키는 역할
### 리커버리 매니저
> DBMS의 백업과 장애시 복구 기능을 수행하고 관리하는 역할
# References

- [https://mentha2.tistory.com/206](https://mentha2.tistory.com/206)
- [https://javannspring.tistory.com/223](https://javannspring.tistory.com/223)
- [https://nomadlee.com/mysql-explain-sql/#type](https://nomadlee.com/mysql-explain-sql/#type)
- [SQL 레벨업, 미크]()