## 프로그램
- 어떤 작업을 위해 실행할 수 있는 파일(실행코드)이며, 저장장치에 저장은 되어 있지만 메모리에는 올라가 있지 않은 정적인 상태이다.

## 프로세스
### 다양한 정의들
- 컴퓨터에서 연속적으로 실행되고 있는 프로그램
- 메모리에 로드되어 실행되고 있는 프로그램의 인스턴스
- 운영체제로부터 시스템 자원을 할당받는 / 운영체제가 관리하는 단위
- 프로세서(처리기, CPU)에 의해 처리되는 프로그램으로 작업(Job), 태그크(Task)라고도 불림
- PCB를 가진 프로그램

### PCB(Process Control Block)

 PCB는 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 공간으로 Task Control Block, Job Control Block 이라고도 한다.  

- 멀티 태스킹 환경에서 컨텍스트 스위칭을 하기 위해 프로세스에 대한 상태와 정보를 스냅샷해놓을 필요가 있고 이를 위해 PCB가 존재한다고 보면 된다.
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 종료되면 PCB는 제거된다.
 
 PCB에 저장되는 대표적인 정보들

| 저장 정보 | 설명 |
| --- | --- |
| 프로세스의 현재 상태 | 준비, 대기, 실행 등의 상태 |
| PID | 프로세스 고유 식별자 |
| 레지스터 정보 | PC, 인덱스 레지스터, 범용 레지스터 등 |
|메모리 관리 정보|페이지 테이블에 대한 정보|
|포인터|부모 프로세스, 자식프로세스, 프로세스가 위치한 메모리, 할당된 자원 등에 대한 주소 기억|

이외에도 다양한 정보들이 PCB에 저장된다.

### 프로세스 상태와 전이
![프로세스 상태 전이 이미지](https://miro.medium.com/max/652/0*g5eqOhLlurGLIz_3.jpg)

#### 프로세스의 상태
- 생성(new) : 작업(Task)을 커널에 등록, PCB를 할당받고 프로세스가 생성되는 단계
- 준비(ready) 
    -  프로세스가 프로세서외에 다른 모든 자원을 할당 받은 상태
    - 프로세스는 준비상태 큐에서 실행을 준비하고 있음
    - new -> ready로의 전이는 Job 스케쥴러에 의해 수행\
- 실행(run)
    - 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
    - 만약 프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료되면 프로세스는 interrupt 되어 준비(ready)상태로 전이
    - 실행중 I/O 처리가 필요하면 대기상태로 전이
    - 준비 상태에서 실행상태로의 전이는 CPU 스케줄러에 의해 수행
 - 대기(wait) : 프로세서 외에 다른 자원할당(주로 I/O)을 기다리고 있는 상태

 - 종료(terminated) : 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태
 
#### 전이 관련 용어
- Dispatch : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당 받아 실행 상태로 전이되는 과정(ready -> run)
- Wake up : 입출력이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정(wait -> ready)

### 프로세스의 메모리 할당
![프로세스 메모리](https://miro.medium.com/max/700/0*jvlxE7iwWWLvzxgo.png)
프로세스는 그림처럼 각각 독립된 메모리 영역을 할당받음
- Code
   실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 공간. CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.

- Data
    코드에서 선언한 전역변수, 정적(Static) 변수가 저장되는 공간.
- Stack
  실행되는 함수 안에서 선언된 지역변수, 매개변수, 리턴값등이 저장되고, 함수 호출시 기록되는 공간
- Heap
  관리가 가능한 데이터 이외에 다른 형태의 데이터를 관리하기 위한 공간(Free Space). 이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제로 반납된다. 

기본적으로 각 프로세스는 다른 프로세스의 할당된 메모리공간에 접근할 수 없으며, 접근이 필요한경우 IPC(Inter Process Comunication)을 사용하게된다.

## 스레드(Thread)

### 스레드 등장 배경
초기  컴퓨터 프로그램들, 그리고 지금도 간단한 프로그램들은 하나의 프로세스만 인스턴스하여 실행된다.
하지만 시대가 흐르면서 프로그램은 더 고도화되고 복잡한 일들을 수행할 수 있게 되었고 이런 일들을 하나의 프로세스로 수행하기가 벅차게 되었다.

따라서 최근 복잡한 프로그램들은 구동시 역할과 책임을 구분한 여러 프로세스가 결합되는 구조며, 프로세스간 IPC를 이용해 데이터를 주고 받으며 실행된다. 

그러나 프로세스를 인스턴스하는 일은 많은 자원을 할당해야하는 무거운일이고 IPC 통신시 손실되는 비용도 무시하지 못한다. 게다가 프로그램의 다양한 기능과 요구마다 프로세스의 생성과 소멸을 반복하는 일도 운영체제에 많은 부담이 드므로 프로그램을 여러 프로세스로 쪼개는 일은 한계가 존재한다.

따라서 **IPC없이도 데이터 송수신이 가능하고, 독립적인 실행 단위로서  프로세스보다 더 작은 실행 단위 개념**이 필요하게 되었고 이것이 바로 **스레드**이다.

### 다양한 정의들
- 프로세스 내에서 실행되는 여러 흐름 단위
- 프로세스의 특정 실행 단위
- 프로세스가 할당받은 자원을 이용하는 실행 단위
- Lightweight Process

### 스레드의 메모리 할당
![스레드 메모리](https://media.vlpt.us/images/raejoonee/post/b91490ed-c67b-407d-8fea-a8d6fdb22559/104.png)
- 스레드는 프로세스 내에서 각각 별도의 레지스터와 Stack을 할당받으며. Code, Data, Heap영역은 공유한다. 따라서 IPC와 같은 별도의 기법없이도 쓰레드간 데이터를 손쉽게 주고 받을 수 있게된다.


## 결론
### 프로세스 vs 스레드
- 프로세스는 운영체제로부터 자원을 할당받아 실행, 스레드는 프로세스로부터 자원을 할당받아 실행

- 하나의 프로세스안에 여러 스레드 생성가능하며, 각 스레드는 개별 스택을 가지고 프로세스의 전역 메모리 공간을 공유하며 프로그램 실행 

### 더 알아 두기
- 멀티 태스킹 / 멀티 스레드 / 멀티 프로세싱
- IPC
- 동기화
- 스케쥴링

## References

- https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
- https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4 
- https://www.fun-coding.org/thread.html