# <더 알아두기> S.O.L.I.D.


객체 지향 프로그래밍을 하는 가장 근본적인 목적은 설계에 있어서 유지보수와 확장이 쉬운 시스템을 만들고
구현에 있어서 코드의 재사용을 줄여 생산성을 높이는것이라 생각한다.

이러한 객체지향의 목적을 달성하기 위해서는 좋은 객체지향 설계를 통해 객체지향 프로그래밍을 해야하며, 

여기서 좋은 객체 지향 설계를 하기위해, 

클린코드의 저자로 유명한 로버트 마틴이 명명한 객체지향 설계의 다섯가지 기본 원칙이 바로 **S.O.L.I.D.** 다.


## S. 단일책임원칙(Single Responsibility Principle)

>객체는 단 하나의 책임만 가져야한다

- 객체지향에서 **책임**이란 메시지를 받은 객체가 **응답할 의무**를 의미하며 객체는 단 하나의 책임만 가져야 한다는 원칙이다.

- 객체가 갖는 책임이 컨텍스상 여러개일 경우, 객체의 응집도가 낮아져서 견고해지지 못하므로 그 책임을 최소화시켜야 한다.

- 가독성 향상과 유지보수가 용이해지고 변경에 의한 연쇄작용에서 유연히 대응가능하다.

- 다만 실무에서 **단하나의 책임** 그 자체를 지키기는 쉽지 않다.


## O. 개방 폐쇄 원칙(OCP, Open-Closed Principle)
>소프트 웨어 요소는 확장에는 Open되있으나 수정에는 Close 되있어야한다

- 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야한다는 의미

- 요구사항 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고 기존 구성요소에서 손쉽게 확장이 가능해야 한다.

### 진정한 의미에서 OCP는 어렵다

- 다형성과 인터페이스(추상화)를 통해 원칙을 *근접하게 달성할수*는 있지만 결국 확장시 클라이언트 객체의 코드가 변경해야 하는 경우가 많다.

- 이를 해결하고 완전한 OCP원칙을 성립하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.**(DI의 필요성)**

## L. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
>서브타입은 언제나 상위 타입으로 교체될 수 있어야한다

- 단순히 문법적인 의미를 넘어서 의미론적으로 상위 타입의 행동을 하위 타입이 무시하거나 재정의하지않고, 확장을 통해 수행해야한다는 뜻이다.

- 자바에서는 클래스, 인터페이스를 통해 상당부분 원칙을 준수할 수 있다.

### 상속과 equals 메서드

- 상속관계에서 자식 클래스에 필드를 추가할 경우 equals 의 대칭성, 추이성 문제가 생긴다.

[[이펙티브 자바] Item 10. equals는 일반 규약을 지켜 재정의해라](https://www.jiniaslog.co.kr/article/view?articleId=102) 					

- 만약 equals 를 instanceof 검사가 아닌 getClass 검사로 재정의할경우 대칭성 추이상은 만족하나 리스코프 치환원칙에 위배된다.

- **컴포지션 패턴**을 사용해서 해결가능하다.


## I.인터페이스 분리원칙(Interface Sergregation Principle)
>클라이언트가 사용하지 않는 인터페이스와 의존관계를 맺어선 안된다

- 인터페이스가 큰 덩어리여선 안되고 하나의 책임만 갖는 인터페이스가 되도록 지향해야 한다.

- 만약 A 인터페이스의 메서드가 3개이고 B 구현체는 메서드 3 개를 다 재정의해서 사용하지만, C 구현체는 메서드 2개만 사용하는 상황일 경우 해당 인터페이스를 찢어서 만드는것이 옳다. 



## D. 의존역전원칙(DIP, Dependency Inversion Principle)

>객체가 의존관계를 성립할 때, 추상성이 낮은 타입보다 추상성이 높은 상위 타입과 의존관계를 맺어야한다

- 하위 모듈의 변경이 상위 모듈의 변경을 요구하는경우 위계관계를 끊는다.

- 실제 사용관계는 그대로지만, 추상화를 매개로 메시지를 주고받으면서 관계를 느슨하게 만든다.

### 실제 코드상에서 진정한 의미의 DIP 준수는 힘들다

- 일반적인 자바 프로그래밍으로는 클라이언트 객체는 반드시 하위 구현체를 의존할 수 밖에 없다.

		public class ClientClass{
			private final ServerInterface serverInterface 	// 추상성이 높은 상위 타입을 바라보더라도
					= new ServerInterfaceImpl();		// 하위 구현체가 코드상 존재할 수 밖에없음
		}

- 하지만 이를 의존성 주입(DI)을 통해 해결 가능하다.




# 3장 함수

## 함수는 최대한 작게 만들어라!

- 로버트 마틴이 주장하는 함수의 적정 길이는 4줄 이하

- 코드 블록은 최대한 중첩되지 않도록 작성할 것
    - 이를 지키기 위해서는 if 문이나 while문등은 되도록이면 1줄로 요약해서 코드블록 중첩이 일어나지 말아야한다.
    - 코드블록이 생길거 같으면 함수로 리팩토링

## 함수의 SRP 준수

- 함수는 한가지 일(한가지 책임)만 해야할것

### 한가지 책임은 어떻게 판단하지?

- 여기서 한가지 일은 **함수 이름 아래(함수 내)에서 모든 문장의 추상화 수준이 동일** 한 경우를 의미한다.


        // 추상화 수준이 동일한 함수의 예시
        // 함수명 : 설정페이지와 해제페이지를 넣는다
        private void includeSetUpAndTearDownPages(){
        
            // 설정페이지들을 만드는 메서드
            includeSetupPages();
            
            // 만들어진 페이지를 전역 변수에 저장
            includePageContent();
            
            // 해제 페이지를 만드는 메서드
            includeTeardownPages();
            
            // 만든 해제 페이지를 전역 변수에 추가 저장
            updatePageContent();
        }
        // 추상화 수준이 더 낮아지지 않고 동일한 레벨에서 함수들이 나열되어 해당 메서드의 이름에 부합할경우 하나의 책임(기능)을 한다고 판단하면 된다!


- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한것


### 함수당 추상화 수준은 하나로

만약 위의 메서드가 

        private void includeSetUpAndTearDownPages(){
        
            includeSetupPages();
            
            includePageContent();
            
    //      includeTeardownPages();
            includeTeardownPage();
            if(isSuite) includeSuiteTeardownPage();
       
            updatePageContent();
        }
        


`includeTeardownPages()` 대신 `includeTeardownPage()`와 `if(isSuite) includeSuiteTeardownPage()`로 작성했다면 이는 `includeSetupPages()`의 추상화 수준과 다른 레벨이므로 ` includeSetUpAndTearDownPages()` 가 한가지 일만 한다고 할 수 없게 된다. 


## 함수의 배치는 추상화 수준 내림차순으로 

- 함수를 작게 쪼개게 되면 많은 함수가 만들어 지는데 이 함수들의 배치는 하이라이키한 계층화 구조로 내림차순하여 배치해라

- 이때 반복되는 함수는 가장 마지막에 사용된 함수를 기준으로 계층을 내려 작성하기


       publilc class FunctionDeploy{
        
         private void 1층함수(){
         2층함수a();
         2층함수b();
         2층함수c();
         }
         
          private void 2층함수a(){
          3층함수a();
          }
        
          private void 3층함수a(){
          }
        
          private void 2층함수b(){
          3층함수b();
          }
        
          private void 2층함수c(){
          3층함수b();
          }
        
          private void 3층함수b(){
          }
        
        }

## Switch문은 되도록 피하자
- 스위치문은 필연적으로 함수를 길게 만든다.

- 만약 스위치문을 사용한다면 가장 추상화 수준이 낮은 레벨에만 사용하여 가독성 저해를 피하자

## 함수명은 서술적인 이름으로

- 함수의 이름은 함수가 하는일을 최대한 잘 표현해야한다.

> "코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드다"

- 길고 서술적인 이름이 짧고 어려운이름, 길고 서술적인 주석보다 훨씬 좋다!


## 함수 인수는 적을수록 좋다

- 함수인수가 많아지면 가독성이 떨어지고 테스트 관점에서도 더 어렵다.

### 출력 인수를 사용하지 말것

- 출력인수란 : 일반적으로 우리는 **인수를 함수 입력**으로 인지하는데 인수에 무언가를 더하는 코드 스타일을 **출력인수**라고 말한다

- 내 프로젝트에서 사용했던 스프링 코드로 예를 들어보겠다.

        // 사용해서는 안되는 출력인수-함수 
        AddLayoutTo(model);
        // 바람직한 함수
        model.addAttribute("articleDto", new ArticleForm());

- 모델에 특정 데이터(Layout)를 담기 위해, *모델을 인수로 집어넣는 함수*를 만들었는데 이런 인수 사용은 모델을 추가한다는건지 모델에 집어넣는다는건지 직관적으로 바로 파악하기 힘드므로 지양하는것이 좋다.

## 부수효과가 없는 함수 만들기

- 함수가 이름에 명시된 기능 이외에 부수 효과를 만들지 않도록 한다. 

## 오류코드보다는 예외처리 사용하기

- 오류코드를 반환하는 함수는 분기를 만드므로 필연적으로 코드블록 중첩을 야기한다.

- 예외처리를 사용할 경우 원래 코드에서 분리되어 훨씬 깔끔해진다.
-  try/catch 블록은 원래 추한 코드이므로 별도 함수로 뽑아내어 가독성을 올리자
    - 예외처리도 하나의 작업이므로 메서드로 빼낼것
  
# References
- [로버트 C.마틴, Clean Code, 인사이트](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966260959&orderClick=LEa&Kc=)