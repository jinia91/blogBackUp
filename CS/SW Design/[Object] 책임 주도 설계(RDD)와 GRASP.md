# 책임 주도 설계(Responsibility Driven Design)
> 책임을 어디에 배치하는가, 책임을 수행할 적절한 객체를 찾고 책임을 수행하는 도중 다른 객체의 도움이 필요할경우 메시지를 먼저 설계하고 그 메시지를 수신할 객체를 찾아 책임을 할당하는 설계방식

## 책임
### 책임의 종류
 - 인지책임: 아는 것 
	 - 전용의(private) 비공개 데이터에 관해 아는 것 
	 - 관련된 객체에 관하여 아는 것 
	 - 자신이 도출하거나 계산할 수 있는 결과에 관하여 아는 것.
 -  실행책임: 하는 것 
	 -  객체를 생성하거나 계산을 하는 것과 같이 무엇을 하는 것 
	 -  다른 객체의 행동을 시작시키는 것 
	 -  다른 객체의 활동을 제어하거나 조정하는 것 
### 책임할당 
- 설계 시에 객체의 클래스에 할당시킴 
	- “Sale” 객체는 “SalesLineItem”을 생성할 책임이 있다.(실행책임) 
	- “Sale“은 판매합계를 알고 있을 책임이 있다. (인지 책임)


## 주요 원칙
### 데이터보다 행동을 먼저 결정

1. 큰 책임을 분할정복하는 과정
2. 큰 책임을 쪼개면 해당 책임을 수행하기 위해 필요한 다른 책임이 발견됨
3. 발견된 책임을 수행할 객체를 선정
4. 수행할 객체에게 필요한 데이터를 결정

### 협력이란 문맥안에서 책임 결정

> 협력에 적합한 정도에 따라 좋은 책임 / 나쁜 책임이 결정되는것이며 객체의 입장에서 판단되는것이 아니다.

- 협력이란 문맥에서 바라보면 결국 메시지의 행동(책임)은 피동적으로 사용되어야 하며, 클라이언트가 사용하게된다. 
- 따라서 사용하는 입장(`클라이언트`)에서 적합한 책임이 협력의 문맥에서 좋은 책임
- 메시지에 행동하는 객체 입장에서 그럴듯한 책임이 좋은 책임이 아니다!
> 관점을 달리 보자는 의미로 항상 책임을 분배할때 사용하는 입장(`API 클라이언트`)에서 생각하자


### 실제 예시

1. 날짜비교를 통한 검증로직을 나이브하게 전체 코드 문맥에서 짠 뒤 
2. 리팩토링할 때 위의 로직을 1차적으로 private 메서드로 분리하고 
3. 이후 별도의 객체에 책임을 주는게 적절할까를 고민하기
4.  validator나 valdateHelper클래스를 만들어 해결


# GRASP (general responsiblity assignment software pattern)

> 일반적인 책임 할당을 위한 소프트웨어 패턴

- 객체에게 책임을 할당할 때 지침으로 삼을수 있는 원칙들의 집합

## 패턴 종류
- 전문가패턴 Information Expert 
- 생성자패턴 Creator 
- 고응집성패턴 High Cohesion 
- 저결합성패턴 Low Coupling 
- 제어기패턴 Controller 
- 다형성패턴 Polymorphism 
- 순수가공패턴 pure fabrication 
- 간접패턴 indirection 
- 보호변형패턴 protected variations


## Information Expert Pattern

> 책임을 수행하는데 필요한 정보를 가지고 있는 객체(`해당 정보의 전문가`)에게 책임 할당하기

- 해당 패턴을 따르면 정보와 책임을 최대한 가까운곳에 위치시킬 수 있기때문에 객체의 응집도를 높이고 캡슐화를 유지하기 쉬워진다.

- 여기서 정보 != 데이터
객체가 **알고** 있으면 되지 **저장** 하고 있음을 의미하는것이 아님

## Low Coupling Pattern

> 소프트웨어 공학에서 흔히 말하는 낮은 결합도를 고려하여 책임을 할당하기

- 결합도를 낮추는 가장 대표적인 방법 예시는 디미터의 법칙을 상기하는것
- 간접적인 의존도는 고결합도를 만든다. 캡슐화를 통해 간접 의존을 없애고 인터페이스만으로 책임을 수행하도록 하기

## High Cohesion Pattern

> 소프트웨어 공학에서 흔히 말하는 높은 응집도를 고려하여 책임을 할당하기

- 높은 응집도를 유지하도록 책임을 할당하여 복잡성 관리하기
### 응집도 측정 방법
#### 메서드와 필드간 의존도 측정
- 클린코드에서는 높은 응집도인지 확인하는 방법으로 객체의 메서드(`책임`)이 인스턴트 필드를 얼마나 의존하는지를 체크하라고 한다.
- 만약 메서드가 10개, 필드가 10개인데 그중 9개의 메서드가 특정 8개의 필드만 사용하고있다면,(2필드는 전혀 의존 X) 나머지 1개의 메서드와 다른 필드 2개는 다른 객체에 할당될 책임인 셈이며, 응집도가 낮음을 의미한다. 
#### 초기화시점과 변경 이유
-  클래스가 하나 이상의 이유로 변경되야 한다면 응집도가 낮은 것
-   클래스의 인스턴스를 초기화할때, 필드 일부만 초기화되거나, 서로다른 시점에 초기화가 된다면 응집도가 낮다는 증거

## Creator Pattern

### 특정 객체 A를 생성하려할 때, 이 책임을 어느 객체에 할당해야하는가? 
	- A객체를 포함하거나 참조하는 객체일때
	- A객체를 기록하는 객체일때
	- A객체를 긴밀히 이용하는 객체일때
	- A객체를 초기화하는데 필요한 데이터를 가지고 있는 객체일때

- 위의 사항에 해당 하는 객체는 이미 A객체를 긴밀히 알고있으므로 생성 책임을 할당하더라도 전체적인 결합도에 영향을 주지 않는다. 

## Polymorphism pattern
> 객체의 타입(`Enum으로 생각하면 편하다`)에 따라 변하는 로직이 있을 때, 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 객체들을 만드는 패턴

- 클린코드에 따르면 `If, Else, 그리고 분기를 만드는 Flag는 추하다`고 말한다.

- `if, else, switch` 등 조건문 분기는 수정하기 어렵고 변경에 취약한 설계이므로, 되도록 다형성을 이용해 설계하는것이 보다 바람직


## Protected Variation Pattern
> 책임 할당의 관점에서 구현의 캡슐화를 의미, 설계에서 변하는것이 무엇인지 고려하고 변하는 개념을 캡슐화해라라는 말처럼, 변화가 예상되는 부분에서 변하지 않을 인터페이스와 구현을 분리하여 캡슐화하는 패턴

- 핵심은 인터페이스와 구현의 분리도 캡슐화임을 인지하는것. 
- 자료구조 관점, 절차지향 관점에서 인스턴트 필드를 private으로 만드는것만이 캡슐화가 아니다. 변화하는 모든것을 감추는것, 인터페이스 뒤로 구현을 감추는것 역시 캡슐화이며 Protedcted Varaation Pattern(변경보호패턴)

## Controller Pattern 

> 책임의 전체적인 조율, 오케스트레이션 하는 책임을 연상하고 객체에게 할당하는 패턴

- 전체 시스템의 흐름을 제어, 혹은 서브 시스템들을 조율하는 오케스트레이션 객체 == `Facade`
- 하지만 `Facade`는 `God Object` Risk가 존재
- OOP 관점으로 생각해볼때 `Facade` 객체는 철저히 인터페이스를 조합한 흐름 제어만 해야하며 구체적인 구현이 존재해선 안됨
-팽창된 제어기가 되지않도록 조심하자

## Pure fabrication Pattern

 
> 공통적인 기능을 제공하는 역할을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어라.
> 
-   Information Expert 패턴을 적용할때, Low Coupling과 High Cohesion의 원칙이 깨어지는 경우가 존재한다.
- 주로 횡단관심사 기능들인 경우로 모든 객체들의 로그 정보를 저장하거나, 메인 로직의 원자성 관리를 하는 등을 예시로 삼을 수 있는데 이때 이 기능의 책임을 수행할 별도의 객체를 만드는 것
- 즉, 도메인에 부여될 책임으로 해석될 수 있으나, Low Coupling과 High Cohesion 관점에서 `순수 가공물(pure fabrication)`객체에 책임을 부여함이 더 효율적일 경우 가상 객체를 만들어 책임을 할당하는 접근법
   
## Indirection Pattern

> 두 객체의 강결합 상황을 피하기 위해 사이에 중간 객체를 두는 패턴

High Coupling을 해소하기 위한 대표적인 소프트웨어 공학기법. 강결합이 예상되는 두 객체사이에(상호 참조 등) 중간객체를 통해 Loose Coupling을 의도하는 접근법이다.



# References
- [오브젝트, 조영호](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LEa&Kc=)
- [https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Indirection](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Indirection)
- [https://velog.io/@lsb156/GRASP-object-oriented-design](https://velog.io/@lsb156/GRASP-object-oriented-design)
- [http://contents.kocw.or.kr/KOCW/document/2014/Seowon/SongHaesang/08.pdf](http://contents.kocw.or.kr/KOCW/document/2014/Seowon/SongHaesang/08.pdf)