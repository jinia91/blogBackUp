# Goal

- 클린 아키텍쳐, 헥사고날 아키텍쳐에 대한 간략 이해
- 기존 프로젝트 아키텍쳐 분석
- 헥사고날 아키텍쳐로 리아키텍쳐링

# Architecture

## Clean Architecture

로버트마틴의 클린아키텍쳐에서 저자는 소프트웨어 공학에서 아키텍쳐란 `개발, 배포, 운영, 유지보수되도록 만들어진 시스템의 형태`로 정의했다.

`우주에서 변화하지 않는 것은 모든것은 변화한다는 사실뿐이다` 라는 그리스 철학자 헤라클레이토스의 말처럼, 모든 것은 변하기 마련이고 

릴리즈된 소프트웨어 역시 지속적으로 변화하기 떄문에, 이 변화에 쉽게 적응하기 위해  가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 설계가 바람직할 것이다.

나는 개인적으로 현대 소프트웨어 공학의 모든 지향점이 결국  유연한 확장과 쉬운 유지관리 두가지 목표를 향해 발전하고 있다고 생각하며, 

클린 아키텍쳐도 같은 관점에서 `유연한 확장과 쉬운 유지관리가 가능한 아키텍쳐` 라고 요약하고 싶다.

## Layered Architecture

계층형 아키텍쳐(Layered Architecture)는 현대 웹 애플리케이션의 보편적인 아키텍쳐 방식으로 손꼽힌다. 

![image](https://blog.kakaocdn.net/dn/b5kygr/btrgB4TYRIV/od3K6YF99SKmBE99KMjrP0/img.png)


1. 화면단을 위한 표층계층
2. 비지니스로직을 담은 도메인계층(혹은 서비스계층, 비지니스 계층 등등)
3. 데이터 영속화를 위한 영속성 계층

3계층으로 정의된 레이어에 각각 해당하는 객체들이 협업하며 하나의 서비스를 제공하는 방식은 웹 어플리케이션을 개발해본 사람이라면 누구나 알고 있을거라 생각한다.

레이어드 아키텍쳐가 얼마나 보편적이면 스프링 프레임워크에서조차 어노테이션에 `org.springframework.stereotype`에 `@Service`와 `@Repository` 어노테이션이 존재한다.

사실 레이어드 아키텍쳐는 견고한 아키텍처 패턴으로, 계층을 잘 이해하고 구성한다면 표층계층이나 영속성계층과 독립적으로 비지니스 계층을 개발할 수 있고, 비지니스 계층에 영향을 주지 않으면서 표층계층이나 영속성 계층을 바꿀수도 있다.

스프링을 공부해봤다면 PSA라 부르는 스프링의 추상화 기술을 사용하여 영속성 db를 손쉽게 갈아끼우는 예제를 한번쯤은 다 접해봤으리라 생각한다.

이처럼 잘 만들어진 계층형 아키텍쳐는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할수 있게 해준다.(`클린아키텍처 15장에서는 이것이 아키텍쳐의 전부라고 정의했다`)

그럼에도 클린 아키텍처에선 레이어드 아키텍쳐가 장기적인 어플리케이션 생명주기 관점에서 지양해야할 패턴이라고 말하는데 그 이유는 무엇일까?

## 전통적 계층형 아키텍처의 단점

### 1. 계층형 아키텍처는 DB 주도 설계를 유도

전통적인 계층형 아키텍쳐를 다시한번 살펴보자

![image](https://blog.kakaocdn.net/dn/b5kygr/btrgB4TYRIV/od3K6YF99SKmBE99KMjrP0/img.png)


표층계층의 객체는 요구받은 요청을 해결하기 위해 비지니스 계층 객체에게 메시지를 보내야한다.

즉 표층 계층은 비지니스 계층을 알아야하며, 이는 비지니스 계층을 의존한다는 의미다.

같은 논리로 비지니스 계층은 영속성 계층을 의존하며 이는 결국 모든 애플리케이션 작동의 토대가 DB에 있다는것을 의미한다.

객체지향적인 관점에서 좋은 설계는 행동을 중심으로 설계하며, 이 행동이 상태를 결정해야하지만, 계층형 아키텍쳐에서는 DB를 설계하고 쿼리를 작성하고, 쿼리를 받는 비지니스 로직을 만든뒤, 그걸 사용하는 웹계층을 만드는 방식으로 자연스럽게 사고하고 구현하게된다.

즉 데이터베이스 중심적인 아키텍처, 개발이 이루어질수밖에 없으며 이는 비지니스 로직이 영속성 계층에 강하게 결합되는 문제가 발생한다.

비지니스 로직을 짤때 서비스는 즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시플러시 등등 영속성에 관련된 작업들을 모두 알아야하고

이는 결국 영속성 코드와 비지니스코드가 얽혀 계층간 분리가 애매해지게 된다.

### 2. 아키텍처가 쉽게 깨진다

전통적 계층형 아키텍처는 강제성이 없기때문에 개발편의상 계층을 쉽사리 깨뜨리는 경우가 많다. 가장 흔한 예시중 하나는 화면 렌더링을 위해 표층계층에서 비지니스 계층을 거치지 않고 바로 영속성계층으로 가는경우인데,

해당 방식으로 개발할 경우 문제점은 테스트의 복잡성이 높아진다는 것이다.


### 3. 서비스의 너비가 지나치게 커진다.

전통적 계층형 아키텍처는 서비스의 너비에 관한 규칙을 강제하지 않는다. 따라서 `@Service`가 붙은 클래스는 시간이 지남에 따라 점점 비대해지고 수많은 비지니스로직을 품게된다.

많은 책임을 가진 객체는 그만큼 테스트하기도 어려워지고, 유지관리에서 작업해야할 특정 로직을 찾기도 어려워진다.

### 결론

계층형 아키텍처도 여러 컨벤션을 엄격히 지키며 개발한다면 유지보수하기 매우 쉬워지며, 변경에도 열려있는 견고한 아키텍처지만

장기적인 관점에서 잘못된 방향으로 흘러가기 쉬운 구조다. 시간이 지날수록 애플리케이션의 품질이 저해되고 유지보수하긴 어려워질것이며, 

이러한 기술부채는 장기적인 생산성 저하를 만들수밖에 없다.

## 헥사고날 아키텍처

### DIP

SOLID원칙중 DIP(의존성 역전 원칙)에 대해 다들 들어봤을거라 생각한다. 나는 dip를 `객체간 의존관계를 맺을때 상위 추상화에 의존해야한다` 정도로 이해했었는데 이번기회에 정의에 대해 좀더 제대로 이해하게 되었다.

일단 보편적인 SW 공학에서 모듈간 의존관계는 항상 상위에서 하위로 맺어지게 된다.


 ![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/a680f964-24c9-413f-9c51-79d2a28fbd84.png)

위의 그림처럼 상위 계층은 항상 하위 계층을 의존하는 구조의 가장 큰 단점은 의존하는 하위계층에 변경이 있을경우 상위계층이 영향을 받는다는 점이다.

여기서 계층을 확실히 분리하기위해선 어떻게 해야할까?

바로 의존관계의 방향을 역전시키는 것이다.

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/2fa93d4b-931d-4b22-8df0-2c6674f2fa42.png)

하위 계층 객체의 구현과 인터페이스를 분리해 인터페이스를 상위계층으로 올려놓으면, 의존관계가 1차적으로는 `하방`에서 `수평`으로 바뀌고

하위계층에 있던 **구현이 상위의 인터페이스를 의존**하므로 최종적으론 `상방`으로 의존관계가 `역전` 된다.


### DIP를 통한 헥사고날 아키텍처(어댑터-포트패턴)

위에서 알아본 DIP를 아키텍처 레벨에서 적극적으로 적용한것이 바로 헥사고날 아키텍처다.



![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/424ffacf-ec59-477b-af1a-93ed3971bbb2.png)


**1. 엔티티(도메인)** 
소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다. 예를 들어 영화예매 소프트웨어가 있다면 해당 소프트웨어는 영화를 좀더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하기 위해 릴리즈된 프로그램이다.
이때 문제를 해결하기 위해 사용자가 프로그램을 사용하는 `분야`를 `도메인`이라고 정의한다.
그리고 그 도메인에서 다루는 핵심 개체를 `엔티티`라고 말한다. 
기존 계층형 아키텍처에서 생각을 해보면 테이블에 매핑되는 엔티티, JPA로 관리되는 엔티티등을 쉽게 예시로 들 수 있다.
<br>
**2. 유스케이스**
클린아키텍처에서 말하는 유스케이스는 `내가 만들고자 하는 시스템(혹은 서비스)을 사용하는 클라이언트가 그 시스템을 통해 하고자 하는 것`을 의미한다.
**3. 헥사고날 아키텍처에서의 도메인과 유스케이스 <=> 비지니스 계층**
<br>
헥사고날 아키텍처에서 말하는 도메인과 유스케이스 관계의 핵심은 비지니스 로직이 도메인에 존재해야한다는 점이다. OOP와도 겹치는 부분인데, 도메인 엔티티는 상태를 가지고 있고, 비지니스 로직상 상태에 변경이 일어난다면 이 변경의 책임은 도메인이 지어야한다는 의미다.
따라서 도메인은 최대한 두껍게 가져가고, 이 도메인의 비지니스 로직을 오케스트레이션하는 역할이 바로 유스케이스의 역할이 된다.
<br>
<br>

**4. 주도하는(Driving) 어댑터와 주도되는(Driven) 어댑터 / 포트**
유스케이스와 엔티티를 이해했다면 어댑터와 포트차례다. 유스케이스의 의존성 화살표방향을 보면 Input Port에는 구현을, Output Port에는 의존관계를 맺고 있음을 확인할 수 있다.
유스케이스에 Input되는 포트와 어댑터를 주도하는 어댑터/포트, 혹은 Incomming Adapter/Port라고 칭하며, 유스케이스에 Output되는 포트와 어댑터를 주도되는 어댑터/포트, 혹은 Outgoinig Adapter/Port라고 부르는데 용어가 친숙하지 않을뿐 사실 `DIP`를 적용한 인터페이스와 구현의 분리가 전부다.
<br>
**5. DIP와 의존성 방향**
쉽게 말해 주도하는 어댑터는 입력포트(`라는 인터페이스`)만 알고, 유스케이스는 입력포트를 구현하는 구현체며, 반대로 유스케이스는 출력포트(`라는 인터페이스`)만 알고있고, 주도되는 어댑터는 출력포트를 구현한 구현체인것이다.

### 포트와 어댑터를 사용하는 이유는?

그림의 의존관계 방향을 보면 그 해답이 보인다.

앞서 설명한것처럼 비지니스에서 가장 중요한 로직들을 엔티티에 담았고 엔티티는 어떠한 의존관계도 갖지 않기때문에, 외부 기술적인 코드의 변화에도 비지니스로직이 흔들리지 않는다.

또한 유스케이스는 엔티티와 출력포트(`인터페이스`)만 알고 있으며, 그 둘을 잘 오케스트레이션하여 클라이언트가 원하는 서비스를 제공한다.

이때, 출력 포트의 구현체인 주도되는 어댑터와 유스케이스는 완전히 계층이 분리되어있으며 의존관계가 없으므로 서로의 변화에 격리되어 변경이 용이해진다.

반대로 주도하는 어댑터는 입력포트를 통해 요청받은 클라이언트의 서비스에 대응해야하며, 이 대응은 구현체인 유스케이스가 하게되므로 위와 같은 논리로 서로의 변화에 격리되어 변경이 용이해진다.

그리고 계층형 아키텍처와 달리 의존성 방향이 도메인과 출력포트로 분리되게 되므로,

도메인과 영속성을 분리하는것도 가능해진다.

궁극적인 헥사고날 아키텍쳐의 강점은 어플리케이션의 핵심인 비지니스로직이 아무런 의존성을 갖지 않는 도메인에 집중되어 `모든 기술적인 코드와 분리 가능성` 에 있다.

# 실제 프로젝트에 적용
## 아키텍처 전략

[기존의 블로그 아키텍처는 계층형 아키텍처 베이스에 어설픈 DDD를 적용해 이도 저도 아닌 난잡한 구조였다.](https://github.com/jinia91/blog/tree/1a58449cd3c316e5cab052fc788a119279929b07)

이번에 헥사고날 아키텍처로 리아키텍쳐링하기에 앞서 세운 기준은 다음과 같다.

### 1. 아키텍처적으로 표현력 있는 패키지 구조
 
아키텍처를 머릿속으로만 생각하는것이 아닌 패키지 구조와 클래스 명칭에 반영시켜 `아키텍처 - 코드 갭(architecture-code gap)`을 줄이도록 했다. 아키텍처에 대한 표현력있는 패키지 구조는 유지관리, 변경과 기능 추가시 항상 아키텍처를 고려하게 강제하며 적극적인 사고를 촉진시켜 아키텍처가 깨지는 상황을 미연에 방지할 수 있다.

### 2. 주도하는 어댑터가 도메인을 모르도록 캡슐화

주도하는 어댑터(`소위 @Controller`)는 입력포트(`UseCaseInterface`)만 알아야하며 내부 구현체나 도메인을 모르도록 철저히 격리시키려했다.

### 3. 영속성 모델과 도메인은 일체화

많은 고민을 했던 부분인데 주도되는 어댑터인 영속성 계층이 도메인을 모르도록 분리하려면 모든 도메인에 영속성 모델이 추가되어야하고 서로간 매핑하는 많은 코드가 추가되어야했다.

헥사고날 아키텍처의 궁극적인 강점은 비지니스 도메인과 모든 기술적인 코드의 분리였지만, 현재 프로젝트의 규모에 `완전매핑전략`을 적용하기엔 너무 오버아키텍처링이 아닐까 생각되었고,

학습목적으로 언젠가는 해보겠지만 일단은 추후 진행하는 방향으로 미루기로 했다.


### 4. 도메인과 유스케이스의 분리

기존 유스케이스에 있던 비지니스 로직들을 도메인으로 이동하거나 도메인이 없다면 만들어서 코드를 재배치 시켜 보다 객체지향적이고 DDD스러운 설계가 되도록 노력했다.

### 5. CQS(Command Query Seperation)
도메인에 변화를 주는 Command와 단순 조회인 Query 유스케이스를 분리하였다. 단순 조회 쿼리는 사이드 이펙트가 발생하지 않으며, 이러한 분리는 핵심 비지니스로직에 대한 집중을 더 확실히 해주고, 유스케이스 구현체가 얇아지므로 사이드 이펙트에대한 추적이 용이해지며 유지관리가 쉬워지는 장점이 있다.

## 최종 결과

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/9672bd14-4f0f-463c-ae85-3acd4d14fe2e.png)

[article 모듈 대한 구조화]

모든 모듈을 위와같이 아키텍처를 표현한 패키지구조로 만들고 역할과 책임을 최대한 분리하며 두꺼운 도메인을 만들려 노력했다.

[깃허브로 코드 확인](https://github.com/jinia91/blog)



## 아쉬운점

교과서적인 구조화를 위해서는 완전매핑전략으로 도메인과 영속성 코드간 분리가 필요한데 이를 실천하지 못한점이 아쉽고,

`default` 접근제한자를 통한 패키지 경계 강제는 고려했지만, 컴파일단계에서 아키텍처가 깨지는것을 방지하는 기술까지는 적용하지 못했다.

보다 나은 아키텍처가 되도록 더 공부해보고 고민해봐야겠다.

# References
- [https://binux.tistory.com/99](https://binux.tistory.com/99)
- [https://jojoldu.tistory.com/603](https://jojoldu.tistory.com/603)
- [https://fsd-jinss.tistory.com/162](https://fsd-jinss.tistory.com/162)
- [https://dundung.tistory.com/183](https://dundung.tistory.com/183)
- [로버트마틴, 클린아키텍처](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966262472&orderClick=LEa&Kc=)
- [톰홈버그, 만들면서 배우는 클린아키텍처](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158392758&orderClick=LEa&Kc=)
- [조영호, 오브젝트](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LEa&Kc=) 