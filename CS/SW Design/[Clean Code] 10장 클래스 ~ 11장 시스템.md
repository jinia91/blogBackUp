# 10장 클래스 - Clean Class 설계하기

## 기본 원칙

### 작성 순서

클래스를 정의하는 표준 자바 관례에 따르면

>1. static public 상수
> 2. static private 변수
> 3. private 변수 ( public 인스턴스 변수는 일반적으로 존재 x)
> 4. public 함수
> 5. public 함수에서 쓰이는 private함수
 
추상화 단계순으로 순차적으로 작성해야한다.

### 캡슐화

[8장을 설명하면서 언급한것처럼](https://www.jiniaslog.co.kr/article/view?articleId=652), 캡슐화는 객체의 실제 구현을 외부로부터 감추는 방식으로

클래스는 일반적으로 캡슐화를 준수해야한다.

다만 반드시 변수와 함수를 숨겨야한다는 법칙도 없으므로, 테스트를 위해 특정 함수나 변수를 protected로 선언하거나 패키지 전체로 공개하는것도 고려해볼 수  있다.

### SRP

[3장에서 살펴봤던 S.O.L.I.D. 원칙중 하나인 SRP는](https://www.jiniaslog.co.kr/article/view?articleId=504) 클래스를 판단하는 아주 중요한 기준이 된다. 

다시한번 개념을 살펴보자.

>객체는 단 하나의 책임만 가져야한다

- 객체지향에서 책임이란 메시지를 받은 객체가 응답할 의무를 의미하며 객체는 단 하나의 책임만 가져야 한다는 원칙이다.

- 객체가 갖는 책임이 컨텍스상 여러개일 경우, 객체의 응집도가 낮아져서 견고해지지 못하므로 그 책임을 최소화시켜야 한다.

- 가독성 향상과 유지보수가 용이해지고 변경에 의한 연쇄작용에서 유연히 대응가능하다.

- 다만 실무에서 단하나의 책임 그 자체를 지키기는 쉽지 않다.

## 클래스는 작아야한다! 

### 1. 적절한 클래스 크기의 기준은?

클린코드의 저자 로버트 마틴은 함수단위를 넘어 클래스 단위에서도 `작은 클래스가 좋은 클래스다` 라는 원칙을 고수한다.

그렇다면 **작은 클래스란 무엇일까?**

책에서 작은 함수는 물리적인 행의 수 4줄 내외로 주장했지만, 클래스는 **맡은 책임의 수**로 클래스의 크기를 측정한다.

즉 적절한 클래스란, 맡은 책임의 수가 `SRP`에 따라 하나인 클래스를 의미한다.

### 2. 그런데 대체 책임이 뭐지?

[객체지향의 사실과 오해](https://www.jiniaslog.co.kr/article/view?articleId=455)에서는 객체지향에서 말하는 `책임`은 메시지를 응답해야할 책임을 뜻하는 말이며, `응집도 있는 요청과 그 응답 행위의 집합`으로 정의했다.

>응집도(Cohesion)란 SW 공학에서 모듈에 포함된 내부 요소들이 하나의 책임/ 목적을 위해 연결되어있는 연관된 정도를 의미한다.

그리고 SRP를 고려하면, 결국 

>하나의 클래스는 하나의 응집도있는 요청과 그 응답행위의 집합만을 책임으로서 가져야 하며, 이때가 가장 적절한 클래스 크기가 되는것으로 정의할 수 있다.

### 3. 그럼 응집도가 있고 없고는 어떻게 판단하지?

본 책에서는 응집도를 확인하는 아주 직관적인 방법을 소개하는데,  `클래스의 함수가 인스턴트 변수를 사용하고 있는지 여부` 로 응집도를 체크한다.

    public class Stack{
        private int topOfStack = 0;
        List<Integer> elements = new LinkedList<Integer>();
        
        public int size(){
            reutnr topOfStack;
        }
        
        public void push(int element){
            topOfStack++;
            elements.add(element);
        }    
        
        public int pop() throw PoppedWhenEmpty{
            if(topOfStack == 0) throw new PoppedWehnEmpty();
            int element = elements.get(--topOfStack);
            elements.remove(toppOfStack);
            return element;
        }
    }
    
위의 코드는 스택을 구현한 간단한 예제코드인데, 3개의 메서드는 모두 인스턴트 변수를 사용하며 긴밀하게 연결되있다.

즉 변수와 함수가 논리적으로 연결되어있다는 의미이며, 응집도가 아주 높은 클래스란 의미이다.

만약, **인스턴트 변수가 아주 많고, 몇몇 함수가 몇몇 인스턴스 변수만 사용한다면, 이는 응집도 덩어리 여러개가 한 클래스안에 옹기종기 모여있다는 신호**이다.

이때 해당 인스턴스 변수와 함수만을 별도 클래스로 분리한다면, 클래스가 짊어진 여러 책임을 덜어내어 보다 작고 깨끗한 클래스 작성이 가능하다!


### 클래스를 설명할때 25단어 내외로 가능한지 자가 체크

책에서는 클래스를 설명할 때, if, and, or, but 등의 접속사 없이 25단어 내외로 깔끔하게 설명가능한지 자가체크를 통해 책임의 크기를 측정해볼것을 권장하고있다.

만약 클래스의 설명이 매우 길어진다면, 클래스를 쪼갤 수 있는지 의심해보자

### 클래스가 많은것이 단점은 아닐까?

클래스가 많아지면 아키텍쳐 큰 구조를 파악하기 힘들어지고, 애플리케이션 복잡도가 높아지는것이 아니냐는 우려가 존재한다.

하지만 책에서는 작은 클래스가 많은 시스템이든 큰 클래스가 몇개뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하며,

어느 시스템이든 익ㅎ실 내용은 그 양이 비슷하다고 말한다.

> "도구 상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍 몇개를 두고 모두를 던져 넣고 싶은가?"

## 변경하기 쉬운 클래스 지향

### `OCP` 와 `DIP`

**유연한 확장과 쉬운 유지보수**를 위해서는 **변경하기 쉬운 클래스**를 만들어야 할 필요가 있다.

여기서 변경하기 쉬운 클래스란, 변경점이 있을때 기존의 코드를 수정하지 않아도 되는 코드를 의미하며(`OCP 준수`), 

이를 위해서는 시스템의(클래스간의) 결합도가 낮아야 하므로 자연스럽게 클래스간 구현이 아니라 추상화에 의존하게 된다.(`DIP 준수`)


# 11장 시스템

## 관심사 분리

10장까지를 통해 낮은 추상화 수준(함수~클래스)에서 어떻게 하면 깨끗한 코드를 유지할수 있을지를 알아보았다.

본장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 여러가지 방법을 소개하는데, 애플리케이션의 시스템을 구상할 때 가장 큰 기준점은 바로 `관심사` 라고 주장한다.

**관심사 분리**는 SW공학에서 가장 오래되고 가장 중요한 설계 기법으로, 주요 관심사 단위로 모듈을 구분하고 구조를 고민하는데서 `클린 시스템`이 시작된다.


## 관심사분리: 객체 생성(construction)과 사용(use) 분리

책에서 소개하는 첫번째 관심사 분리는 시스템 제작과 시스템 사용의 분리다.

애플리케이션은 필연적으로 최초 구동시 객체 생성을 하게 되고, 그다음 객체를 사용하게 된다.

특정 객체 생성을 그 객체를 사용할 다른 객체에서 하는`지연 초기화`등의 방법도 존재하지만, 이는 본래 비지니스 로직을 책임질 객체가 다른 객체의 생성까지 책임지게 되므로, 책에서는 권장하지 않는다.

### 1. Main 분리
>객체의 생성과 관련된 모든 코드를 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 몯느 객체가 생성되었고, 의존성이 연결되었다고 가정하는 방법

![image](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F67da096b-3a46-4969-b58b-e468a787ebc4%2FUntitled.png&blockId=b3ffa438-f2c6-4ebc-9d81-8c20ec9fddfa&width=2400)

### 2. 팩토리
> 객체가 생성되는 시점을 애플리케이션이 결정할 필요(지연 초기화 등)시, 객체를 생성해주는 `추상 팩토리 패턴 등`을 사용하는 방법

![image](https://media.vlpt.us/images/gentledot/post/d76364d8-5df6-4f36-b7d0-71fee4547371/image.png)

오로지 객체 생성에만 책임이 있는 별도의 모듈을 만듬으로써, `SRP`를 어기지 않고도 지연초기화전략을 수립할 수 있다.

### 3. DI

의존성 주입은 모듈의 사용과 제작을 분리하는 강력한 메커니즘중 하나다. 

제어의 역전 기법을 의존성 관리에 적용함으로써, 초기설정만 별도로 해주면 객체를 생성하고, 특수한 컨테이너가 객체간 의존성 연결을 책임진다. 

따라서 클래스들은 의존성과 초기화에 대한 관심사에서 벗어나 본연의 비즈니스로직만 책임질수 있게된다.

## 관심사분리: 횡단 관심사 분리(Cross-Cutting Concerns)

![image](https://t1.daumcdn.net/cfile/tistory/0311115050FE424A37)

모듈의 전통적인 경계를 넘어 여러 모듈에서 공통적으로 나타나 객체지향 관점으로 다루기 곤란한 영역이 존재한다.

메인 비지니스 코드가 아닌 기술적 코드인 경우가 대부분인데, 그림에서처럼 로깅, 보안, 영속화 트랜잭션 처리 등이 대표적이다.

물론 원론적으론 객체지향 관점에서 모듈화되고 캡슐화된 방식으로 구현은 가능하다. 하지만 현실적으로는 구현된 코드가 여러 모듈, 객체로 흩어지게 되므로 객체간 결합도가 높아지고 중복코드가 양성된다.

이런 관심사를 `횡단 관심사`라고 부르며 관점(Aspect)라는 모듈 구성 개념으로 해결한다.

책에서는 자바 프록시 기술, 프록시 기술을 사용한 프레임워크(SPRING), AspectJ 프레임워크에 대해 간략하게 소개하고 있다.

근래 스프링 AOP에대해 학습했었는데, 본 책에 대한 이야기이기도 하기 때문에 차후 별개의 포스팅으로 정리해보겠다.


# References
- [로버트 C.마틴, Clean Code, 인사이트](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966260959&orderClick=LEa&Kc=)

