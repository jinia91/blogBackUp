## 전송계층 개요
### 전송 계층의 두가지 역할

물리계층, 데이터 링크 계층, 네트워크 계층 이 3계층이 있으면 목적지에 데이터를 전달할 수 있다.

 하지만 네트워크 계층은 목적지까지 **경로**만 제공할 뿐이고, 데이터 링크계층은 Point to Point, **1대1 단말간의 통신만 보장**하기 때문에 

수많은 단말들이 복합적으로 얽힌 네트워크간 통신시 데이터의 전달의 신뢰를 책임지지는 않는다.

여기서 전송계층은 **흐름 / 혼잡 / 오류 제어를 통해 목적지에 신뢰할 수 있는 데이터 전달이 가능하도록** 프로토콜을 제공한다.

또한 도착한 데이터가 단말의 **어떤 애플리케이션으로 전달될지 식별**하는 기능도 제공한다.

### 연결형 통신과 비연결형 통신

전송 계층의 특징은 `신뢰성/정확성` 과 `효율성` 으로 구분할 수 있다.

- `신뢰성 / 정확성` : 데이터를 목적지에 문제없이 전달하기 위해 다양한 절차를 거침
    - 연결형 통신, TCP
- `효율성` : 데이터의 빠르고 효율적인 전달을 위해 최소한의 절차만 거침
    - 비연결형 통신, UDP

![image](https://media.vlpt.us/images/april_5/post/2bade79f-eacd-4100-b01a-bc9111317e3a/OSI%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%89%E1%85%A9%E1%86%BC%20%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC.jpeg)

## TCP

### TCP란?

>전송 제어 프로토콜(Transmission Control Protocol)은 IP 네트워크의 두 단말 간의 **연결형 통신**을 위한 전송 계층 호스트 간 프로토콜이다. 


### 세그먼트(segment)와 TCP 헤더

![image](https://media.vlpt.us/images/april_5/post/5441b02c-56f9-49c3-9f77-dd0cb1b72939/image.png)

상위계층에서 내려온 데이터를 전송할때 4계층에서는 다른계층과 마찬가지로 추가 정보를 담은 헤더를 붙인다. 

TCP 프로토콜을 사용할 때 부착되는 헤더를 **TCP 헤더**라고 부르며, 이 데이터를 **세그먼트**라고 한다.


|  |  |
| --- | --- |
| 출발지 포트 번호 | 데이터가 생성된 어플리케이션 포트 |
|  목적지 포트 번호| 데이터가 도착할 어플리케이션 포트 |
| 일련번호 | 송식층이 수신측에 데이터가 몇번째 데이터인지 알려주는 역할 |
| 확인 응답번호 | 수신측이 몇번째 데이터를 수신했는지 송신측에 알려주는 역할, 확인 응답 |
|  헤더길이| TCP 헤더 크기 |
| 예약 영역 | 미래에 사용하기 위해 남겨둔 예비 필드 |
|  코드비트| 6비트로 구성되어있으며 연결 제어 정보가 기록된다. |
|  체크섬| 헤더 및 데이터 에러확인 |
|  긴급포인터| URG플래그가 1이라면 이 포인터가 가르키고 있는 데이터를 우선처리 |
| 옵션 | TCP 기능을 확장할때 쓰는 가변 필드 |


### 연결형 통신? 연결지향?

네트워크계층의 **인터넷 프로토콜**(IP)은 비연결 프로토콜로서 데이터를 한차례 송신하거나 수신하면 거기서 통신은 종료된다.(단방향, 일회성)

하지만 TCP는 **연결형 통신, 연결 지향 프로토콜**로서  본격적인 통신에 앞서 **연결**(Connection)이라는 **가상의 논리적 통신로**를 확보한뒤 데이터를 주고 받는다.

![image](https://evan-moon.github.io/static/025135c6a12488fad9c15e904f065386/6af66/logical-connection.png)


TCP는 대체 왜 이런 연결을 유지하는 것일까? 

그 이유는 바로 연속적인 데이터 전송의 신뢰성을 위해서이다.

기본적으로 TCP는 패킷 전송 방식을 사용하기 때문에 보내려고 하는 데이터를 여러 개의 패킷으로 쪼개서 보낸다.  

문제는 수신하는 단말은 여러 단말과 동시에 통신을 하기 때문에 수많은 패킷들이 여기저기서 몰려들어온다. 이때 누가 보낸 몇번째 패킷인지 정보가 없다면 굉장히 혼란스러울 수 밖에 없다.

여기서 TCP는 `A단말과 B단말 연결상태` `A단말과 C단말 연결상태` `A단말과 D단말 연결상태` 등 각기기간 연결 상태를 따로 구분하는 논리적 가상 회선을 만들어 통신을 하여 이 문제를 해결한다.

그리고 상대방과 연결 상태를 만들거나 해제하기 위해 특별한 과정을 거치는데, 이 과정을 핸드쉐이크(Handshake)라고 한다.

### 3-Way 핸드 셰이크 - 연결을 만드는 과정


![image](https://yohanpro.com/media/images/network/TCP/codeBeat.png)

연결(connection)은 TCP 헤더의 코드 비트를 사용하여 제어하며,  SYN(연결 요청)과 ACK(확인 응답)를 사용하여 확립 할 수 있다.

신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷 교환을 세 번(three-way handshake) 확인 한다

>3-WAY 핸드셰이크(three-way handshake): 데이터를 보내기 전에 연결을 확립하기 위해 패킷 요청을 세번 교환하는 것을 의미.
핸드셰이크는 사람들이 상대방을 확인하고 악수를 하는 것처럼 데이터 통신에서도 확실하게 데이터가 전송되었는지 확인하면서 이루어지는 통신 수단이다.

![image](https://media.vlpt.us/images/april_5/post/4c4f039f-64a0-4088-91f2-2caa4aa64adf/3-way%20%E1%84%92%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%E1%84%89%E1%85%A8%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3.jpeg)

1. 최초에 데이터를 목적 단말로 송신하기 전, 통신을 허가받기 위해 수신단말에게 **SYN**[1] 코드비트를 보낸다.

2. 수신 단말은 TCP 프로토콜하에 세그먼속 SYN 코드비트에서 [1]을 확인하고 통신이 가능한 경우 응답으로 **ACK** 코드비트[1]와 상대도 통신이 가능한지를 묻는 **SYN**[1] 요청을 보낸다.
3. 송신 단말은 ACK와 SYN의 코드비트를 통해 상대가 데이터 송신이 준비됬음을 확인하고, 자신도 송수신이 가능함을 확인시켜주기 위해 **ACK**[1] 코드를 보낸다.

다음 세 과정을 통해 두 단말은 서로 송수신이 가능함을 확인함으로서 논리적으로 **연결** 상태를 유지하게 되며 이를 **가상회선** 이라 부른다.

### 4-Way 핸드 셰이크 - 연결을 끊는 과정

![image](https://media.vlpt.us/images/april_5/post/3cfa9f72-7464-44d0-a44b-4d88ea13f5e6/image.png)

데이터를 전송할때뿐만 아니라 연결을 종료할때도 요청을 교환해야 한다.

연결을 끊을때는 **FIN**(연결 종료)과 **ACK**(확인 응답)를 사용한다.

- 단말1에서 단말2로 연결종료요청(FIN) 비트코드를 보낸다.
- 단말2는 연결종료 응답(ACK) 을 반환한다
- 단말2에서는 또한 다시 FIN 비트코드를 보낸다.
- 단말1은 FIN코드의 응답으로 ACK 코드를 반환한다.


### TCP의 흐름 제어
>송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 제어하기 위한 기법으로 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.

-  Stop and Wait(정지 - 대기) : 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다. 이러한 구조로 인해 비효율적이라는 단점
-  Sliding Window(슬라이딩 윈도우) : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법

### TCP의 오류제어
ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다.

- Stop and Wait ARQ : 송신 측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무에 따라 ACK 혹은 NAK(Negative Acknowledgement)를 보내는 방식
- Go-Back-n ARQ 
- SR(Selective-Reject) ARQ

### TCP의 혼잡 제어

 송신측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다.

 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실이 발생한다. 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어의 개념이다.

- AIMD(Additive Increase Multicative Decrease)
- Slow Start

## UDP
### UDP란?
> UDP(User Datagram Protocol) : 사용자 다이어그램 프로토콜. 전송 계층에서 데이터를 효율적이고 빠르게 보낼 때 사용되는 프로토콜

UDP는 비연결형 통신이라서 데이터를 전송할 때 TCP처럼 시간이 걸리는 확인 작업을 일일이 하지 않는다.

UDP는 TCP와 달리 효율성을 중요하게 여기는 프로토콜 이라 TCP와 같은 신뢰성과 정확성을 요구하게 되면 효율이 떨어진다.

![image](https://media.vlpt.us/images/april_5/post/287837cf-4eb8-49ba-a71d-daa59c24a3e7/image.png)

### UDP 등장배경

IP의 비연결성, 비신뢰성 한계를 극복하고자 나온게 TCP가 아닌가? 그런데 어째서 비연결형 통신인 UDP가 필요한건지 의문이 들 수  있다.

TCP 통신은 데이터 신뢰성을 보장하기 위한 방식이기 때문에 누락된 데이터를 모두 받기 위한 메커니즘이 정의되어 있다. 이것이 이메일이나 파일 전송과 같은 분야에서는 필수불가결의 요소였으나, 실시간 스트리밍 서비스에서는 문제가 된다. 

간단히 전체 영상에서 도트 하나 못 받은 것 때문에 버퍼링 돌린다고 재생이 수시로 중지된다고 생각해보자. 혼잡제어를 한다고 보내는 양도 조절하기 때문에 영상 데이터의 퀄리티가 안정적이지 못할 것이고 스트리밍 기능은 정상적으로 작동하기 어려울 것이다. 

실시간 스트리밍에서는 음성이나 화면이 조금 깨지더라도 실시간으로 데이터가 원활히 전송되는것이 더 중요하다.

결국 이처럼 **신뢰성보다 효율성이 더 중요한** 통신을 하기 위해 제시된 것이 UDP 이다.

### UDP 헤더와 특징

![image](https://media.vlpt.us/images/april_5/post/4b991034-4eb5-4da1-ad5c-f827fc1276c8/image.png)

UDP 헤더는 데이터가 송수신되는 포트와 최소한의 오류제어 기능만을 가지고 있다.  확인응답 같은 것이 없기 때문에 TCP보다 용량이 가볍고 송신속도가 빠르다. 하지만 확인응답을 하지 못하기때문에 신뢰도가 TCP보다 떨어지게 된다. 

### 차세대 통신기술은 UDP?
사실 UDP도 얼마든지 신뢰성있는 네트워크를 구축할 수 있다. TCP에서 하는 신뢰성 작업을 상위 계층에서 **프로그래머가 직접 코딩**해서 구현하면 된다. 

보통 TCP로 쓰면 효율이 떨어져서 쓰기 싫은데, 신뢰성을 보장해줘야 되는 상황일 경우 사용하는 방법이다. TCP에 쓰이는 흐름 제어 및 신뢰성 제어 알고리즘은 현대에 들어서는 성능 상으로 지나치게 비효율적이라는 평을 받고 있어 개발자들이 UDP 소켓에서 더 효율적인 알고리즘으로 TCP의 기능을 구현하려는 시도가 이어지고 있다.

50여년간 쌓여온 레거시 통신기술로 이미 비대해져버린 TCP 헤더와는 달리 UDP 헤더는 도화지와 같아서 내 서비스에 정말 필요한 네트워크 기능만 추가하여 훨씬 효율적이고 빠른, 그러면서 신뢰성이 보장되는 통신이 가능하기 때문에 최근 각광받고 있다.

차세대 통신 프로토콜인 QUIC와 HTTP/3은 TCP가 아닌 UDP를 기반으로 개발되고 있으며, 암호화 통신 방식도 TLS의 기능을 UDP에 구현한 보안 소켓인 DTLS (Datagram Transport Layer Security) 기술이 등장했다.



## References
- [제로베이스, 컴퓨터공학 전공자 따라잡기](https://zero-base.co.kr/)
- [미즈구치 카츠야, 모두의 네트워크, 길벗](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791160505030)
- [https://evan-moon.github.io/2019/11/17/tcp-handshake/](https://evan-moon.github.io/2019/11/17/tcp-handshake/)
- [https://velog.io/@jsj3282/TCP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4-%EC%98%A4%EB%A5%98%EC%A0%9C%EC%96%B4](https://velog.io/@jsj3282/TCP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4-%EC%98%A4%EB%A5%98%EC%A0%9C%EC%96%B4)
- [https://roka88.dev/114](https://roka88.dev/114)