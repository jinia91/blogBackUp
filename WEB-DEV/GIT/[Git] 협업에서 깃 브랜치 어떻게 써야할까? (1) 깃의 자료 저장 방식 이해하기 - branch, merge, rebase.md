# 개요
입사를 하고 직면한 가장 큰 문제 중 하나는 Git 숙련도인거 같다. 

그동안 Git을 버전관리, 형상 관리 용도라기 보다는 백업 레포지토리, `CI / CD`를 위한 리모트 레포지토리 정도로만 사용해왔고, 

협업 경험이 현저히 부족하다보니 Git의 브랜치 관리 전략, 머지전략에 대한 지식이 부족해서 이참에 공부해야될 필요성을 느꼈다.

## Goal

- 깃의 자료 저장 방식 이해
- 브랜치 / 머지 제대로 이해하기
- 브랜치 관리 전략에 대한 숙지 (2편에서)
- 머지 전략에 대한 숙지 (2편에서)

### 앞으로 더 알아볼 것

- 깃에 대한 이해도 더 자세히!
- 깃 액션


# git, checksum, branch

## 깃이 데이터를 저장하는 방식 이해하기

>깃이 무엇인지에대한 기본 사전지식은 알고 있다는  가정하에 포스팅을 진행하겠다.

1. 깃이 `add` 를 통해 로컬 레포지토리에 있는 데이터를 `Staging area`로 저장할 때, 모든 데이터의 체크섬`(sha-1로 만들어진 git의 기본 데이터 단위)`을 각각 만들어 함께 저장 한다.
     - 체크섬을 통해 중복검사, 오류검사를 행하므로 데이터의 무결성 보존이 가능!<br>
         ![첨부 이미지](https://github.com/jinia91/blogBackUp/blob/main/img/41620075-1997-4e80-8a2f-60de07f291b6.png?raw=true)
2. 깃이 `commit`을 통해 `Staging area`에서 원격 레포지토리로 데이터를 저장할 때, 해당 체크섬을 들고있는 루트 디렉토리와 하위 디렉토리 트리들을 객체로 만들어 저장한다.(`트리 객체`)
3. 그 다음, 위의 `트리개체`를 가리키는 포인터와 커밋시 메타정보(커밋메시지, 저자 등)을 가진 `커밋 개체`를 만들고 이를 외부에 노출하는 개체로 사용한다.
    - 이때 `커밋 개체` 안에는 이전 커밋에 대한 포인터도 저장되므로, 현재의 커밋이 어떤 커밋을 기준으로 변경된 데이터인지(parent, ancestor) 확인할 수 있다.<br>
        ![첨부 이미지](https://github.com/jinia91/blogBackUp/blob/main/img/10cc921b-0ee1-4f9a-af48-7582fcf3d46e.png?raw=true)<br>[바로 직전 커밋에 대한 포인터도 저장!]
    - 최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나 이상 있으며, **여러 커밋 포인터**를 들고 있는 경우도 존재한다.

## 브랜치(Branch)

### 브랜치를 포인터로 이해하기

깃의 저장방식을 이해하고, `커밋개체`를 이해했다면, 브랜치는 이 `커밋 개체을 가리키는 포인터`라고 이해하면 편하다.

![image](https://git-scm.com/book/en/v2/images/branch-and-history.png)

여기서 브랜치를 이름 그대로 **가지**의 개념으로 이해했었다면, 이 포인터라는 개념이 생소할수도 있다. 

하지만 다음 과정을 잘 따라가보면 브랜치를 포인터로 이해하는것이 꽤 직관적임을 확인할 수 있을것이다.


**1. 브랜치 따기**

위의 그림에서 `master` 브랜치가 가리키는 `f30ab`에서 새로운 브랜치 `testing`을 따보자

>git branch testing

![image](https://git-scm.com/book/en/v2/images/head-to-master.png)

[현재 작업중인 `master`브랜치가와 `testing` 브랜치가 같은 스냅샷을 가르키고 있는 상태, `HEAD`를 통해 현재 작업중인 브랜치를 확인가능하다.]

**2.브랜치 이동하기**

> git checkout testing

![image](https://git-scm.com/book/en/v2/images/head-to-testing.png)

[`testing`으로 `HEAD`가 이동해있다]

**3. 분리한 브랜치에서 작업하고 커밋하기**

> git add . // 작업후 <br>
> git commit -m "testing에서 커밋하기"

![image](https://git-scm.com/book/en/v2/images/advance-testing.png)

[분리된 브랜치에서 커밋을 하면 해당 `커밋 개체`는 이전 커밋을 포인터로 가리키고 있으며, `testing` 브랜치 역시 해당 커밋을 가리킨다. 또한 현재 해당 브랜치를 작업중이므로 `HEAD`도 현 브랜치를 가리키고있다.]

- 여기서 핵심은 `master` 브랜치는 `f30ab` 스냅샷을 그대로 가리키고 있다는점!

**4. master 브랜치로 이동해서 다른 작업후 커밋해보기**

>git checkout master // 작업후 <br>
> git add . <br>
> git commit -m "마스터에서 커밋하기"

![image](https://git-scm.com/book/en/v2/images/advance-master.png)

여기서 브랜치가 마치 나무가지처럼 양갈래로 찢어져있고, 이런 모양을 본따 `branch`로 명명했다고 생각된다.

하지만 포인터로 이해해도 전혀 문제가 없을것이다.

`master` 브랜치는 현재 `c2b9e 커밋개체`를 가리키고 있고, 해당 `커밋개체`는 메타정보로 `이전 커밋개체 f30ab`를 가리킨다.

즉 `c2b92`와 `87ab2` `커밋개체` 안에 들어있는 각각 데이터들은 다른 데이터임을 짐작할 수 있다.

### 브랜치 합치기(Merge)를 포인터로 이해하기

이제 위의 상황을 응용해서 실제 운영환경에서 브랜치를 왜 쪼개고, 어떻게 합치는지(Merge) 이해해보자.

간략한 설명을 위해 리모트 레포지토리에 대한 전제나 `push`과정은 생략하고 진행하겠다.

![image](https://git-scm.com/book/en/v2/images/basic-branching-3.png)

    <시나리오>
    - 항상 master 브랜치가 가리키는 커밋 스냅샷을 실제 운영환경에서 배포하고 있는 상황
    - 새로운 기능 개발을 위해 iss53 브랜치를 따서 새로운 기능작업도중 `C3` 커밋을했다.
    - 운영환경에서 장애가 발생하여 핫픽스가 필요해진 상황! 모든 개발팀은 핫픽스부터 먼저 해야한다!

**1. 핫픽스 브랜치 따서 작업하기**

기존 작업하던 `iss53` 브랜치에서 `master` 브랜치로 변경하여 `C2`스냅샷을 워킹 디렉토리로 담아야하므로   

>git checkout master

을 해야한다.

>이때! <br>만약 내가 하고 있던 작업(`C3`에서 +@)이 존재하고, 해당 작업을 커밋하기엔 너무 애매한 상황일수도있다.  이때 `stashing`이나 `clean`을 이용하면 보다 유연하게 상황을 헤쳐나갈 수 있다. 해당 기능은 나중에 별도 포스팅해보겠다.

이후 `hotfix` 브랜치를 따서 빠르게 장애를 해결후 커밋을 했다.

![image](https://git-scm.com/book/en/v2/images/basic-branching-4.png)

여기서 중요한점은 우리는 `hotfix` 브랜치를 따서 장애해결을 위한 작업은 했지만, 운영서버는 항상 `master` 브랜치가 가리키는 스냅샷으로만 배포하는 전략이므로

**운영서버는 아직 아무런 변경도 안되었고, 장애도 아직 해결되지 않았다는 점이다.**

브랜치를 포인터로 생각하고 바라보니 좀더 이해하기 편하지 않은가?
~~나만 그런가~~

**2. `hotfix` 브랜치와 `master` 브랜치 통합하기**

이제 `hotfix` 브랜치와 `master` 브랜치를 합쳐야한다. 

여기서 포인터의 관점으로 생각해보면 `master` 브랜치가 `hotfix` 가 가리키는 스냅샷으로 가야하므로, **`master`브랜치가 `hotfix` 브랜치로 합쳐져야한다**고 이해해보자.

그럼 먼저 마스터 브랜치로 이동후 브랜치를 합쳐야하므로

> git checkout master <br>
> git merge hotfix

라고 명령어를 작성하면

![image](https://git-scm.com/book/en/v2/images/basic-branching-5.png)

위와같은 그림이 되면서 `master` 브랜치가 `c4`를 가리키게 된다!

이제 장애를 고친 `c4`버전이 운영서버로 배포됬으므로 무사히 핫픽스가 끝났다.

**※fast-forward merge?**

이때 git에서는 

    ...
    Fast-forward
     .. file changed, .. insertions(+)
     ...



라는 메시지가 나오는데 여기서 `fast-forward`는 머지 방식중의 하나를 뜻한다.

위의 브랜치 병합 시나리오를 잘 생각해보면, `C2 커밋 개체`와 `C4 커밋 개체`는 단순히 조상 개체와 자손 개체이며, 병합이라기 보다는 `커밋의 단순 이동(fast-forward)` 으로 바라볼수도 있다.

이런 시나리오일때, 깃은 `fast-forward`라고 칭한다.

**3. 기능 개발로 돌아가서 임무 완수하기**

핫픽스를 무사히 고쳤으므로 이제 기능개발로 돌아가자.

![image](https://git-scm.com/book/en/v2/images/basic-branching-6.png)

기능 개발을 완수한 뒤, 커밋을 하면 위와같은 그림이 된다.

이제 아까 핫픽스처럼 브랜치 병합을 하면 되는데, 잘 생각해보면 상황이 조금 다르다는것을 알 수 있다.

아까는 각각의 브랜치가 가리키는 커밋들이 조상과 자손이라 자손으로 이동하면 됬지만,

지금은 서로 조상만 같지 다른 작업물이 담긴 `커밋개체`들이므로 `Fast-forward` 병합이 될 수 없다.

**3-way Merge**

이때 깃은 `3-way Merge` 전략을 사용하는데 이방식은 공통 조상인 `C2` 커밋개체를 원본으로 

1. 각 브랜치의 공통 조상`C2 커밋개체`를 기준으로
2. 각 브랜치가 가리키는 `C4`의 변경점,(diff) `C5`의 변경점을 분석하고 
3. 해당 변경점들이 충돌이 없을경우 3개의 `커밋개체`를 모두 통합하여 
4. 새로운 `커밋개체`를 만든다.
5. 그리고 현재 브랜치를 새로운 커밋개체가 바라보게 한다.

따라서 
> git checkout master <BR>
> git merge iss53
를 시행하면

![image](https://git-scm.com/book/en/v2/images/basic-merging-2.png)

위와 같이 `C2`를 조상으로 `C4`와 `C5`를 부모로하는 새로운 `C6 커밋개체` 가 생성되며 `checkout`한 브랜치가 `master`였으므로

`master`는 `c6`을 바라보고 새로운 기능이 추가된 신버전 운영서버가 배포된다!

**머지 충돌**

위에서 간략하게 언급했지만, 만약 `C4`와 `C5` 가 같은 코드를 수정했다면 깃은 어떤 코드를 우선시해서 병합해야할지 모르므로 충돌이 일어난다.

이때는 다양한 충돌 해결방식이 있지만, 기본적으로는 우선시 되는 커밋을 알려주거나, 충돌된 부분을 손수 수정해서 다시 커밋후 합치면 해결된다.

충돌에 대한 다양한 해결방식은 추후 포스팅에서 자세히 알아볼 예정!

### 3way merge 상황에서 fast-forward merge로 해결하는 방법 `rebase`

깃에서 브랜치를 합치는 방식은 2가지로 위에서 살펴봤던 Merge 외에도 `Rebase`가 있다.

![image](https://git-scm.com/book/en/v2/images/basic-rebase-1.png)

위의 상황에서 `c4`와 `C3`를 합치는 다른 방식은 `C4 커밋 개체` 가 들고 있는 `부모 커밋개체 포인터`를 `C3`으로 변경(Rebase)하는 것이다.

깃의 데이터 저장방식에서 설명한것처럼 `커밋개체`는 `부모 커밋개체의 포인터`를 가지고 있기 때문에, 해당 포인터만 변경하면 아래와 같은 그림이 된다.

> git checkout experiment<br>
 git rebase master

![image](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)

물론 이상황이 일어나기 위해서는 `c4`와 `c3` 커밋간 충돌이 없어야한다.

이후 `master` 브랜치를 `experiment`와 병합하면 `fast-forward`방식으로 병합이 가능하다.

### rebase의 장단점

위의 그림처럼 rebase를 사용하면 브랜치를 분리하는걸 일종의 신버전 패치하는 방식으로 관리가능하기 때문에, 히스토리가 굉장히 깔끔해진다.

하지만 rebase는 기존 `c4`커밋이 사라지게 되므로 협업을 할때 제대로된 컨벤션이 없다면 큰 혼란을 야기할 수 있다.

만약 다른 팀원이 `c4`에서 브랜치를 다시 따서 작업을 하거나, 다른 브랜치에서 `c4` 커밋을 머지했다고 생각해보자. 하지만 나는 이후 `c4`를 지우고 `c4' 커밋개체`를 만들었으므로, 

서로간의 커밋 히스토리가 엉망으로 꼬이게 된다. 물론 해결은 가능하지만, 많은 고생을 하게 되므로 

resbase 전략은 확실한 팀 컨벤션을 수립한 뒤 수행토록하자.


   