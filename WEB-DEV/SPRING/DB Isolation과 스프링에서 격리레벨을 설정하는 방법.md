# Isolation이란?

독립성(Isolation)은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. (`ACID의 I`)
즉, 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미하며,  트랜잭션 실행내역이 연속적이어야 함을 의미한다. 
다만 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다.
  - 모든 요청을 전부 직렬화시킨다면, 한번에 하나의 트랜잭션밖에 수행하지 못하므로 그만큼 성능에 제약이 발생할 수 밖에 없으며, 이를 조율하기위해 isolation level이 존재

# Isolation level

트랜잭션간 고립수준을 얼마나 둘것인가에 대한 정의

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

## READ UNCOMMITTED
A트랜잭션이 데이터 변경을 가질때, 아직 커밋됨과 상관없이 다른 트랜잭션이 해당 변경을 읽어내는 레벨
즉 가장 낮은 수준의 격리(isolation) 레벨을 의미

### trouble case
- A트랜잭션이 특정 데이터 컬럼을 ++ 쳐서 `3` 이됨
- 아직 커밋 전
- B트랜잭션이 그 특정데이터를 조회
- `3` 으로 조회됨

=> dirty read

만약 A트랜잭션이 문제가 발생해 rollback 한다면?
B트랜잭션은 `3` 을 가지고 이미 트랜잭션쿼리를 수행하기때문에 데이터 정합성에 큰 문제가 생김!

권장 x

## READ COMMITTED
- 커밋된 트랜잭션을 다른 트랜잭션이 읽는 고립수준
- 가장 일반적인 격리 레벨
- 같은 트랜잭션 내에서 같은 select을할때 다른 값이 나오는 부정합이 발생할 위험이 존재(`NON-REPETABLE READ` 부정합)

### trouble case
- A트랜잭션에서 select 으로 count가 3
- B트랜잭션에서 count를 4로 만들고 commit
- A트랜잭션에서 select으로 count를 조회하니 4가되는 부정합 발생

비즈니스 로직의 정합성 중요성에 따라 문제가 될 수 있음!


## Repetable Read

- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회
- 거의 완전한 고립레벨
- 트랜잭션에 시퀸셜한 고유 번호(id)를 가지고 자신보다 이후 트랜잭션에서 먼저 commit이 발생할때, select이 이후 일어날경우 undo영역에 백업된 데이터를 불러와 커밋 이전 영역을 재참조
- 성능상 하위 레벨과 크게 차이는 안남


### trouble case 1 - update 부정합
- 1번트랜잭션이 select 으로 count 3 조회
- 2번트랜잭션이 select 으로 count 3 조회
- 1번트랜잭션에서 count 3 일때 4로 update
- 2번 트랜잭션이 count 3 일때 4로 update -> 0 affected

### trouble case 2 - Phantom Read
A트랜잭션중 B트랜잭션에서 특정 데이터가 insert되고 이를 A트랜잭션에서 update 치는경우 A트랜잭션에서 이후부터 select이 되는 현상

## Serializable
가장 단순하고 엄격하게 모든 트랜잭션을 순차적으로 발동

# 스프링에서 Isolation 설정하기

## `@Transactional`

> 트랜잭션이란 광의로 정의하면 쪼갤 수 없는 업무 처리의 최소 단위를 의미하며, 협의로 정의하면 DB에만 한정하여 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위로 이해할 수 있다.

- `@Transactional` 은 클래스나 메서드에 붙여줄 경우, 해당 범위 내 메서드가 트랜잭션이 되도록 보장
- `@Transactional` 이 붙은 함수를 호출하면 해당 연산은 고립되어 다른 연산과의 혼선으로 인해 잘못된 값을 가져오는 경우가 방지

## `@Transactional` 의 내부 동작 원리

스프링의 AOP를 학습할때 흔히 언급되는것처럼 `@Transactional`은 내부적으로 프록시 패턴을 사용해 AOP로 구현되어있다.

- JPA를 사용한다면 `@Transactional`의 함수 호출시 영속성 컨텍스트를 사용하기 때문에, 영속성 컨텍스트의 이해도 필요

## `@Transactional`의 옵션 - Isolation

`@Transactional` 어노테이션을 부착할때 몇가지 옵션을 부여할 수 있는데, Isolation level도 역시 줄수 있다.

만약 옵션을 주지않으면 DB의 Default 설정값을 사용하게되며 mySql의 경우 기본 설정값으로 `Repetable Read` 를 쓴다. 

> 이는 DB가 변경될경우 많은 설정값이 달라질수 있음을 의미하므로, 기존 코드가 Isolation 옵션을 고려하지 않은 상태에서 데이터베이스 마이그레이션을 고려한다면 유의하자!

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/ea052527-a56d-4dea-b398-875756740261.png)

## `@Transactional`의 옵션 - Propagation

> 트랜잭션의 전파범위, 전파 레벨을 설정하는 옵션

부가적으로 `@Transactional`의 대표 옵션중 하나인 Propagation 설정을 알아보자

코드를 짜다보면 트랜잭션이 걸려있는 함수를 다시 트랜잭션이 걸린 함수 안에서 호출하는 코드를 꽤 빈번히 작성하게 된다.

>특히 `service`가 `service`를 참조하면서 dept를 깊게 가져가는 복잡한 로직의 경우들인데, 개인적으론 이런 방식의 구조는 건강하지 못하다고 생각하며 facade 계층을 통해 보다 추상화시켜 조율시키는게 바람직하다 생각한다.

이때, 실제 트랜잭션은 어떻게 생성될까? 이에 대한 동작 설정을 해주는 옵션이 바로 Propagation, 전파레벨 설정이다.

### `REQUIRED` (기본값)

- 부모 트랜잭션이 존재한다면 종속 트랜잭션은 부모 트랜잭션에 통합

아무런 설정을 두지않을경우 동작으로 내부의 함수는 별도의 트랜잭션을 형성하지 않고 부모 트랜잭션 하나에서 모든 동작이 이루어지게된다.

만약 부모 트랜잭션이 없다면, 새로운 트랜잭션을 생성하게된다.

아무런 설정을 하지 않는다면 기본값.

### `SUPPORTS`

- 부모 트랜잭션이 존재하면 합류, 없을경우 트랜잭션을 생성하지 않고 로직을 수행한다.

### `MANDATORY`

- 부모 트랜잭션이 존재하면 합류, 없으면 에러가 터진다


### `REQUIRES_NEW`

- 항상 새로운 트랜잭션을 시작한다.
- 그러나 이미 진행중인 트랜잭션이 존재하면, 해당 트랜잭션을 잠시 보류시킨다.

### `NOT_SUPPORTED`

- 부모 트랜잭션이 있을경우 이를 보류하고 해당 로직을 동작하며, 없을시에도 트랜잭션없이 로직을 작동시킨다.
- `NEVER`와 유사하게 트랜잭션에서 분리하기위해 사용

### `NEVER`

- 부모 트랜잭션이 존재시 예외, 없을시 로직수행, 트랜잭션 절대 안쓰기!

### `NESTED`
- 부모 트랜잭션이 존재할 경우, 해당 트랜잭션의 세이브 포인트를 기록한다.
이후 해당 트랜잭션 내에 종속 트랜잭션을 만들어 작업을 하게 되는데, 만약 그 과정에서 비즈니스 로직에 예외가 발생하면 세이브 포인트로 롤백한다.

즉, 하위 트랜잭션은 상위 트랜잭션에 영향을 받지만, 상위 트랜잭션은 하위 트랜잭션에 영향을 덜 받도록 구축할 수 있다.

만약 상위 트랜잭션이 없다면, REQUIRED처럼 작동한다.

