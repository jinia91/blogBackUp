# N+1 문제와 해결법
## N+1 문제란?

> JPA상에서 Entity를 조회할 때, 만약 Entity안에 연관관계로 엮여있는 엔티티가 존재하며, 그 엔티티도 조회할 경우, 그 엔티티의 갯수만큼(N개) 쿼리가 추가로 발생하는 현상을 말한다.

## 글로벌 페치 전략과 N+1 문제

### 글로벌 페치 전략이란

- Fetch란 사전적 의미로 가져오다(≒bring), 자아내다(≒derive) 등 의 뜻
- **JPA가 엔티티를 조회할 때, 연관관계로 엮여있는 엔티티들을 어떻게 가져올 것인지 정하는 전략**으로,  `일 대 다` 관계를 갖는 엔티티에서 정의해줄 수 있으며. `즉시로딩`이 기본 전략으로 되어있다.

### 즉시 로딩(fetch = FetchType.EAGER)

즉시 로딩은 엔티티를 조회할 때 해당 엔티티의 그래프상 하위 엔티티까지를 일괄적으로 SQL상의 `join` 을 통해 가져오는 전략이다.

### 즉시 로딩의 문제점
**1. 사용하지 않는 엔티티도 로딩하게 된다.**
-    만약 마이바티스를 통해 네이티브 쿼리를 사용하고, 엔티티를 생각하지 않은 설계라면, 특정 화면을 위해 ARTICLE_TITLE만 가져오는 SQL을 날릴수 있을것이다.
 - 그러나 JPA는 엔티티단위로 관리하기 때문에 위의 케이스에서 ARTICLE 엔티티 전체를 모두 조회해야한다.
- 즉시로딩의 경우는 여기에 더해 ARTICLE 엔티티에 정의된 댓글리스트나, 태그 리스트 등도 모두 가져오므로 굉장히 비효율적인 작동을 하게 된다.

**2. JPQL 사용시 N+1문제의 발생**

- JPQL을 사용할 경우, JPA는 **JPQL을 SQL로 번역하는 과정에서** 글로벌 페치 전략을 참고하지 않는다.

- 따라서 프록시를 가진 엔티티 인스턴스를 생성한다.
- **문제는 이후 영속성 컨텍스트로 저장하는 과정에서, 글로벌 페치 전략을 참조하게 되는데**, 이때 연관관계에 묶여있는 엔티티들이 프록시이므로 해당 프록시가 영속성 컨텍스트에 존재하는지 확인한다.
- 없을 경우 해당 엔티티들을 채워넣기위해 엔티티갯수만큼(N개) 추가 쿼리가 날라가게 된다.


### 지연 로딩(fetch = FetchType.LAZY)

- **지연 로딩은 엔티티를 조회할 때 해당 엔티티의 그래프상 하위 엔티티를 모두 프록시로 대체하는 전략**으로, 연관관계의 주인에 해당하는 엔티티들을 조회하지 않는다.

- 지연로딩을 하면 즉시로딩시 발생하는 1번 문제, 사용하지 않는 엔티티 로딩 문제를 해결할 수 있다.

### 지연로딩과 N+1 문제

N+1 문제는 결국 연관관계로 맺고 있는 `X 대 다` 에서 발생하게 되는데, 지연로딩을 하더라도 하위 엔티티를 조회하는 상황에서는 똑같은 문제가 발생할수밖에 없다.


         // 이처럼 연관관계에 묶인 엔티티를 프록시로 태그를 가져오더라도 
         //비지니스로직상에서 해당 엔티티를 조회할경우 쿼리가 추가로 발생한다.
         .....
         List<Article> articleList = articleRepository.findAll();
         for(Article article : articleList){
             article.getTagList().get(0);
         }
         ....

### 해결법은?

위의 문제는 근본적으로 내가 필요로 하는 엔티티를 한번에 로딩하지 않았기 때문에 발생한다.

즉 네이티브쿼리라면 Join을 통해 한방쿼리를 날려 가져오면 될일을 JPA의 메서드 쿼리를 사용하거나 정확하지 않은 JPQL을 사용했기때문에 일어나는 일이다.



## JPQL의 페치 조인

### 조인을 안쓰고 왜 페치조인을?

JPQL상에서도 JOIN은 존재한다. 문제는 JPQL상의 JOIN은 우리의 일반적인 생각이랑 조금 다르게 동작한다는것이다. 

만약 `SELECT a FROM Article a join a.tagList` 로 JPQL을 작성할 경우 실제 날라가는 쿼리는 다음과 같다.

        SELECT 
            ARTICLE_컬럼들,
        FROM
            ARTICLE
        INNER JOIN
            TAG    

즉 조인은 날렸는데 정작 연관된 엔티티들의 컬럼들은 조회하지 않는다.

당연히 영속성 컨텍스트에 TAG는 저장되지 않으므로, `article.getTagList()`를 조회하게되면 N+1문제가 발생한다.


### 페치조인(fetch join)

JPQL 문법인 페치조인을 사용하면 `x대 다` 연관관계에 묶여있는 엔티티들을 모두 가져올 수 있다.

-`SELECT a FROM Article a join fetch a.tagList`

### 페치조인의 한계

1. **페이징 API 사용이 불가능하다.**

하이버네이트에서 컬렉션(`X대 다, 연관관계주인`)을 페치조인하고 페이징 API를 사용하면 DB에서 페이징이 처리되어 반환되는것이 아니라

엔티티의 모든 DB를 다 메모리에 올리고 메모리상에서 페이징처리를 수행한다.

성능상, 메모리가 어마어마하게 낭비될수 있으므로 절대 추천하지 않는다.

또한 컬렉션이 아닌 단일값 연관 필드의 경우 페치조인을해도 페이징이 불가능하다.


2. **둘 이상의 컬렉션을 페치할 수 없다.**

페치조인은 기본적으로 `일대다` 관계에서 일을 조회 연관된 `다 - 엔티티들`을 함께 가져오기위해 사용한다.

만약 이런 연관관계가 여러개라면(`A 대 다, A 대 다`) 두개의 컬렉션을 페치로 가져와야하는데 이경우 컬렉션의 카티션곱이 형성되어 정상적인 데이터 처리가 불가능해지고 `not simultaneously fetch multiple bag`에러가 발생한다.


이 문제는 나도 프로젝트를 진행하면서 겪었는데, 결국 쿼리를 두번 날려서(하나는 페치조인으로 묶어서, 다른 하나는 별개의 쿼리로) 해결했다.


# References
- [김영한, 자바 ORM 표준 JPA 프로그래밍, 에이콘](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788960777330&orderClick=LEa&Kc=)
- [김영한, 자바 ORM 표준 JPA 프로그래밍 - 기본편, 인프런](https://www.inflearn.com/course/ORM-JPA-Basic)
- [https://cobbybb.tistory.com/18](https://cobbybb.tistory.com/18)
- [https://www.popit.kr/jpa-n1-%EB%B0%9C%EC%83%9D%EC%9B%90%EC%9D%B8%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/](https://www.popit.kr/jpa-n1-%EB%B0%9C%EC%83%9D%EC%9B%90%EC%9D%B8%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/)